webpackJsonp([3],{fZvo:function(e,t,n){"use strict";function r(e){return S._27(0,[(e()(),S._4(0,0,null,null,9,"a",[["class","mat-list-item"],["mat-list-item",""],["routerLinkActive","active"]],[[1,"target",0],[8,"href",4]],[[null,"focus"],[null,"blur"],[null,"click"]],function(e,t,n){var r=!0;return"focus"===t&&(r=!1!==S._18(e,1)._handleFocus()&&r),"blur"===t&&(r=!1!==S._18(e,1)._handleBlur()&&r),"click"===t&&(r=!1!==S._18(e,4).onClick(n.button,n.ctrlKey,n.metaKey,n.shiftKey)&&r),r},E.c,E.a)),S._3(1,1097728,null,2,P.b,[S.k,[2,P.f]],null,null),S._23(603979776,4,{_lines:1}),S._23(335544320,5,{_hasAvatar:0}),S._3(4,671744,[[7,4]],0,U.n,[U.l,U.a,B.h],{routerLink:[0,"routerLink"]},null),S._19(5,2),S._3(6,1720320,null,2,U.m,[U.l,S.k,S.B,S.h],{routerLinkActive:[0,"routerLinkActive"]},null),S._23(603979776,6,{links:1}),S._23(603979776,7,{linksWithHrefs:1}),(e()(),S._25(9,2,["\n        ","\n      "]))],function(e,t){e(t,4,0,e(t,5,0,"/operators",t.context.$implicit.name)),e(t,6,0,"active")},function(e,t){e(t,0,0,S._18(t,4).target,S._18(t,4).href),e(t,9,0,t.context.$implicit.name)})}function a(e){return S._27(0,[(e()(),S._4(0,0,null,null,9,"mat-nav-list",[["class","operator-list mat-nav-list"],["role","navigation"]],null,null,null,E.d,E.b)),S._3(1,49152,null,0,P.f,[],null,null),(e()(),S._25(-1,0,["\n      "])),(e()(),S._4(3,0,null,0,2,"h3",[["class","category-subheader mat-subheader"],["mat-subheader",""]],null,null,null,null,null)),S._3(4,16384,null,0,P.e,[],null,null),(e()(),S._25(5,null,["",""])),(e()(),S._25(-1,0,["\n      "])),(e()(),S.Z(16777216,null,0,1,null,r)),S._3(8,802816,null,0,B.j,[S.N,S.K,S.q],{ngForOf:[0,"ngForOf"]},null),(e()(),S._25(-1,0,["\n    "]))],function(e,t){e(t,8,0,t.component.groupedOperators[t.context.$implicit])},function(e,t){e(t,5,0,t.context.$implicit)})}function o(e){return S._27(0,[(e()(),S._4(0,0,null,null,7,"button",[["class","sidenav-toggle mat-mini-fab"],["color","primary"],["mat-mini-fab",""]],[[24,"@growInOut",0],[8,"disabled",0]],[[null,"click"]],function(e,t,n){var r=!0;return"click"===t&&(r=!1!==S._18(e.parent,7).toggle()&&r),r},D.d,D.b)),S._3(1,180224,null,0,J.b,[S.k,N.a,q.f],{color:[0,"color"]},null),S._3(2,16384,null,0,J.e,[[2,J.b],[8,null]],null,null),(e()(),S._25(-1,0,["\n  "])),(e()(),S._4(4,0,null,0,2,"mat-icon",[["class","mat-icon"],["role","img"]],null,null,null,F.b,F.a)),S._3(5,638976,null,0,W.b,[S.k,W.d,[8,null]],null,null),(e()(),S._25(-1,0,["view_list"])),(e()(),S._25(-1,0,["\n"]))],function(e,t){e(t,1,0,"primary"),e(t,5,0)},function(e,t){e(t,0,0,"in",S._18(t,1).disabled||null)})}function l(e){return S._27(0,[S._23(402653184,1,{_sidenav:0}),(e()(),S._4(1,0,null,null,14,"mat-sidenav-container",[["class","operator-container mat-drawer-container mat-sidenav-container"]],null,null,null,z.c,z.b)),S._3(2,1490944,null,2,K.f,[[2,$.c],S.k,S.x,S.h,K.a],null,null),S._23(603979776,2,{_drawers:1}),S._23(335544320,3,{_content:0}),(e()(),S._25(-1,2,["\n  "])),(e()(),S._4(6,0,null,0,5,"mat-sidenav",[["class","operator-list-sidenav mat-drawer mat-sidenav"],["tabIndex","-1"]],[[40,"@transform",0],[1,"align",0],[2,"mat-drawer-end",null],[2,"mat-drawer-over",null],[2,"mat-drawer-push",null],[2,"mat-drawer-side",null],[2,"mat-sidenav-fixed",null],[4,"top","px"],[4,"bottom","px"]],[["component","@transform.start"],["component","@transform.done"],[null,"keydown"]],function(e,t,n){var r=!0;return"component:@transform.start"===t&&(r=!1!==S._18(e,7)._onAnimationStart(n)&&r),"component:@transform.done"===t&&(r=!1!==S._18(e,7)._onAnimationEnd(n)&&r),"keydown"===t&&(r=!1!==S._18(e,7).handleKeydown(n)&&r),r},z.d,z.a)),S._3(7,3325952,[[2,4],[1,4],["operatorSidenav",4]],0,K.e,[S.k,q.g,q.f,N.a,[2,B.d]],{mode:[0,"mode"],opened:[1,"opened"],fixedInViewport:[2,"fixedInViewport"],fixedTopGap:[3,"fixedTopGap"]},null),(e()(),S._25(-1,0,["\n    "])),(e()(),S.Z(16777216,null,0,1,null,a)),S._3(10,802816,null,0,B.j,[S.N,S.K,S.q],{ngForOf:[0,"ngForOf"]},null),(e()(),S._25(-1,0,["\n  "])),(e()(),S._25(-1,2,["\n  "])),(e()(),S._4(13,16777216,null,2,1,"router-outlet",[],null,null,null,null,null)),S._3(14,212992,null,0,U.p,[U.b,S.N,S.j,[8,null],S.h],null,null),(e()(),S._25(-1,2,["\n"])),(e()(),S._25(-1,null,["\n"])),(e()(),S.Z(16777216,null,null,1,null,o)),S._3(18,16384,null,0,B.k,[S.N,S.K],{ngIf:[0,"ngIf"]},null),(e()(),S._25(-1,null,["\n"]))],function(e,t){var n=t.component;e(t,2,0),e(t,7,0,n.sidenavMode,!n.smallScreen,!0,n.operatorMenuGap),e(t,10,0,n.categories),e(t,14,0),e(t,18,0,n.smallScreen)},function(e,t){e(t,6,0,S._18(t,7)._animationState,null,"end"===S._18(t,7).position,"over"===S._18(t,7).mode,"push"===S._18(t,7).mode,"side"===S._18(t,7).mode,S._18(t,7).fixedInViewport,S._18(t,7).fixedInViewport?S._18(t,7).fixedTopGap:null,S._18(t,7).fixedInViewport?S._18(t,7).fixedBottomGap:null)})}function s(e){return S._27(0,[(e()(),S._4(0,0,null,null,7,"div",[["class","extra-tip"]],null,null,null,null,null)),(e()(),S._25(-1,null,["\n  "])),(e()(),S._4(2,0,null,null,2,"mat-icon",[["class","tip-info mat-icon"],["role","img"]],null,null,null,F.b,F.a)),S._3(3,638976,null,0,W.b,[S.k,W.d,[8,null]],null,null),(e()(),S._25(-1,0,["info"])),(e()(),S._25(-1,null,["\n  "])),(e()(),S._4(6,0,null,null,0,"h3",[],[[8,"innerHTML",1]],null,null,null,null)),(e()(),S._25(-1,null,["\n"]))],function(e,t){e(t,3,0)},function(e,t){e(t,6,0,t.context.$implicit.text)})}function i(e){return S._27(0,[(e()(),S._4(0,0,null,null,7,"div",[["class","extra-tip"]],null,null,null,null,null)),(e()(),S._25(-1,null,["\n  "])),(e()(),S._4(2,0,null,null,2,"mat-icon",[["class","tip-warning mat-icon"],["role","img"]],null,null,null,F.b,F.a)),S._3(3,638976,null,0,W.b,[S.k,W.d,[8,null]],null,null),(e()(),S._25(-1,0,["warning"])),(e()(),S._25(-1,null,["\n  "])),(e()(),S._4(6,0,null,null,0,"h3",[],[[8,"innerHTML",1]],null,null,null,null)),(e()(),S._25(-1,null,["\n"]))],function(e,t){e(t,3,0)},function(e,t){e(t,6,0,t.context.$implicit.text)})}function u(e){return S._27(0,[(e()(),S.Z(16777216,null,null,1,null,s)),S._3(1,802816,null,0,B.j,[S.N,S.K,S.q],{ngForOf:[0,"ngForOf"]},null),(e()(),S._25(-1,null,["\n"])),(e()(),S.Z(16777216,null,null,1,null,i)),S._3(4,802816,null,0,B.j,[S.N,S.K,S.q],{ngForOf:[0,"ngForOf"]},null),(e()(),S._25(-1,null,["\n"]))],function(e,t){var n=t.component;e(t,1,0,n.tips),e(t,4,0,n.warnings)},null)}function c(e){return S._27(0,[(e()(),S._4(0,0,null,null,13,"tr",[],null,null,null,null,null)),(e()(),S._25(-1,null,["\n      "])),(e()(),S._4(2,0,null,null,1,"td",[],null,null,null,null,null)),(e()(),S._25(3,null,[" "," "])),(e()(),S._25(-1,null,["\n      "])),(e()(),S._4(5,0,null,null,1,"td",[],null,null,null,null,null)),(e()(),S._25(6,null,[" "," "])),(e()(),S._25(-1,null,["\n      "])),(e()(),S._4(8,0,null,null,1,"td",[],null,null,null,null,null)),(e()(),S._25(9,null,[" "," "])),(e()(),S._25(-1,null,["\n      "])),(e()(),S._4(11,0,null,null,1,"td",[],null,null,null,null,null)),(e()(),S._25(12,null,[" "," "])),(e()(),S._25(-1,null,["\n    "]))],null,function(e,t){e(t,3,0,t.context.$implicit.name),e(t,6,0,t.context.$implicit.type),e(t,9,0,t.context.$implicit.attribute),e(t,12,0,t.context.$implicit.description)})}function p(e){return S._27(0,[(e()(),S._4(0,0,null,null,1,"h2",[],null,null,null,null,null)),(e()(),S._25(-1,null,[" Parameters "])),(e()(),S._25(-1,null,["\n"])),(e()(),S._4(3,0,null,null,25,"table",[["class","parameter-table mat-elevation-z2"]],null,null,null,null,null)),(e()(),S._25(-1,null,["\n  "])),(e()(),S._4(5,0,null,null,16,"thead",[],null,null,null,null,null)),(e()(),S._25(-1,null,["\n    "])),(e()(),S._4(7,0,null,null,13,"tr",[],null,null,null,null,null)),(e()(),S._25(-1,null,["\n      "])),(e()(),S._4(9,0,null,null,1,"th",[],null,null,null,null,null)),(e()(),S._25(-1,null,["Name"])),(e()(),S._25(-1,null,["\n      "])),(e()(),S._4(12,0,null,null,1,"th",[],null,null,null,null,null)),(e()(),S._25(-1,null,["Type"])),(e()(),S._25(-1,null,["\n      "])),(e()(),S._4(15,0,null,null,1,"th",[],null,null,null,null,null)),(e()(),S._25(-1,null,["Attribute"])),(e()(),S._25(-1,null,["\n      "])),(e()(),S._4(18,0,null,null,1,"th",[],null,null,null,null,null)),(e()(),S._25(-1,null,["Description"])),(e()(),S._25(-1,null,["\n    "])),(e()(),S._25(-1,null,["\n  "])),(e()(),S._25(-1,null,["\n  "])),(e()(),S._4(23,0,null,null,4,"tbody",[],null,null,null,null,null)),(e()(),S._25(-1,null,["\n    "])),(e()(),S.Z(16777216,null,null,1,null,c)),S._3(26,802816,null,0,B.j,[S.N,S.K,S.q],{ngForOf:[0,"ngForOf"]},null),(e()(),S._25(-1,null,["\n  "])),(e()(),S._25(-1,null,["\n"])),(e()(),S._25(-1,null,["\n"]))],function(e,t){e(t,26,0,t.component.operatorParameters)},null)}function b(e){return S._27(0,[(e()(),S._4(0,0,null,null,3,"mat-toolbar",[["class","operator-name mat-toolbar"]],[[2,"mat-toolbar-multiple-rows",null],[2,"mat-toolbar-single-row",null]],null,null,le.b,le.a)),S._3(1,4243456,null,1,se.a,[S.k,N.a],null,null),S._23(603979776,1,{_toolbarRows:1}),(e()(),S._25(3,0,["\n  ","\n"])),(e()(),S._25(-1,null,["\n"])),(e()(),S._4(5,0,null,null,3,"mat-toolbar",[["class","signature mat-toolbar"]],[[2,"mat-toolbar-multiple-rows",null],[2,"mat-toolbar-single-row",null]],null,null,le.b,le.a)),S._3(6,4243456,null,1,se.a,[S.k,N.a],null,null),S._23(603979776,2,{_toolbarRows:1}),(e()(),S._25(8,0,["\n  ","\n"])),(e()(),S._25(-1,null,["\n"]))],null,function(e,t){var n=t.component;e(t,0,0,S._18(t,1)._toolbarRows.length,!S._18(t,1)._toolbarRows.length),e(t,3,0,n.operatorName),e(t,5,0,S._18(t,6)._toolbarRows.length,!S._18(t,6)._toolbarRows.length),e(t,8,0,n.operatorSignature)})}function m(e){return S._27(0,[(e()(),S._4(0,0,null,null,0,"img",[["class","marble-diagram"]],[[8,"src",4],[8,"alt",0]],null,null,null,null))],null,function(e,t){var n=t.component;e(t,0,0,n.url,S._7(1,"Diagram of how ",n.operatorName," works"))})}function d(e){return S._27(0,[(e()(),S._4(0,0,null,null,4,"div",[["class","marble-wrapper mat-elevation-z2"]],null,null,null,null,null)),(e()(),S._25(-1,null,["\n  "])),(e()(),S.Z(16777216,null,null,1,null,m)),S._3(3,16384,null,0,B.k,[S.N,S.K],{ngIf:[0,"ngIf"]},null),(e()(),S._25(-1,null,["\n"])),(e()(),S._25(-1,null,["\n"]))],function(e,t){e(t,3,0,t.component.url)},null)}function h(e){return S._27(0,[(e()(),S._4(0,0,null,null,26,"div",[["appHighlightJs",""],["class","code-example"]],null,null,null,null,null)),S._3(1,8404992,null,0,be,[S.k,S.x],null,null),(e()(),S._25(-1,null,["\n  "])),(e()(),S._4(3,0,null,null,22,"div",[["class","code-block mat-elevation-z2"]],null,null,null,null,null)),(e()(),S._25(-1,null,["\n    "])),(e()(),S._4(5,0,null,null,13,"div",[["class","example-header"]],null,null,null,null,null)),(e()(),S._25(-1,null,["\n      "])),(e()(),S._4(7,0,null,null,0,"div",[["class","header-title"]],[[8,"innerHTML",1]],null,null,null,null)),(e()(),S._25(-1,null,["\n      "])),(e()(),S._4(9,16777216,null,null,8,"button",[["aria-label","Copy"],["class","mat-icon-button"],["mat-icon-button",""],["matTooltip","Copy"],["value","Copy"]],[[8,"disabled",0]],[[null,"click"],[null,"longpress"],[null,"keydown"],[null,"touchend"]],function(e,t,n){var r=!0,a=e.component;return"longpress"===t&&(r=!1!==S._18(e,12).show()&&r),"keydown"===t&&(r=!1!==S._18(e,12)._handleKeydown(n)&&r),"touchend"===t&&(r=!1!==S._18(e,12).hide(1500)&&r),"click"===t&&(r=!1!==a.copyToClipboard.emit(e.context.$implicit.code)&&r),r},D.d,D.b)),S._3(10,180224,null,0,J.b,[S.k,N.a,q.f],null,null),S._3(11,16384,null,0,J.d,[],null,null),S._3(12,147456,null,0,me.c,[de.a,S.k,he.d,S.N,S.x,N.a,q.c,q.f,me.a,[2,$.c]],{message:[0,"message"]},null),(e()(),S._25(-1,0,["\n        "])),(e()(),S._4(14,0,null,0,2,"mat-icon",[["class","mat-icon"],["role","img"]],null,null,null,F.b,F.a)),S._3(15,638976,null,0,W.b,[S.k,W.d,[8,null]],null,null),(e()(),S._25(-1,0,["content_copy"])),(e()(),S._25(-1,0,["\n      "])),(e()(),S._25(-1,null,["\n    "])),(e()(),S._25(-1,null,["\n    "])),(e()(),S._4(20,0,null,null,4,"div",[["class","bin-wrapper"]],null,null,null,null,null)),(e()(),S._25(-1,null,["\n      "])),(e()(),S._4(22,0,null,null,1,"iframe",[],[[8,"src",5],[8,"title",0]],null,null,null,null)),S._21(23,1),(e()(),S._25(-1,null,["\n    "])),(e()(),S._25(-1,null,["\n  "])),(e()(),S._25(-1,null,["\n"]))],function(e,t){e(t,12,0,"Copy"),e(t,15,0)},function(e,t){e(t,7,0,t.context.$implicit.name),e(t,9,0,S._18(t,10).disabled||null),e(t,22,0,S._26(t,22,0,e(t,23,0,S._18(t.parent,0),t.context.$implicit.externalLink.url)),t.context.$implicit.name)})}function f(e){return S._27(0,[S._20(0,fe,[ve.c]),(e()(),S._4(1,0,null,null,1,"h2",[],null,null,null,null,null)),(e()(),S._25(-1,null,[" Examples "])),(e()(),S._25(-1,null,["\n"])),(e()(),S.Z(16777216,null,null,1,null,h)),S._3(5,802816,null,0,B.j,[S.N,S.K,S.q],{ngForOf:[0,"ngForOf"]},null),(e()(),S._25(-1,null,["\n"]))],function(e,t){e(t,5,0,t.component.operatorExamples)},null)}function v(e){return S._27(0,[(e()(),S._4(0,0,null,null,1,"h2",[],null,null,null,null,null)),(e()(),S._25(-1,null,[" Walkthrough "])),(e()(),S._25(-1,null,["\n"])),(e()(),S._4(3,0,null,null,1,"div",[["class","walkthrough-container"]],[[8,"innerHTML",1]],null,null,null,null)),(e()(),S._25(-1,null,["\n\n"])),(e()(),S._25(-1,null,["\n"]))],null,function(e,t){e(t,3,0,t.component.operatorWalkthrough)})}function g(e){return S._27(0,[(e()(),S._4(0,0,null,null,1,"h2",[["class","related-operators"]],null,null,null,null,null)),(e()(),S._25(-1,null,[" Related Operators "]))],null,null)}function y(e){return S._27(0,[(e()(),S._4(0,0,null,null,6,"li",[],null,null,null,null,null)),(e()(),S._25(-1,null,["\n    "])),(e()(),S._4(2,0,null,null,3,"a",[],[[1,"target",0],[8,"href",4]],[[null,"click"]],function(e,t,n){var r=!0;return"click"===t&&(r=!1!==S._18(e,3).onClick(n.button,n.ctrlKey,n.metaKey,n.shiftKey)&&r),r},null,null)),S._3(3,671744,null,0,U.n,[U.l,U.a,B.h],{routerLink:[0,"routerLink"]},null),S._19(4,2),(e()(),S._25(5,null,[" "," "])),(e()(),S._25(-1,null,["\n  "]))],function(e,t){e(t,3,0,e(t,4,0,"/operators",t.context.$implicit))},function(e,t){e(t,2,0,S._18(t,3).target,S._18(t,3).href),e(t,5,0,t.context.$implicit)})}function O(e){return S._27(0,[(e()(),S.Z(16777216,null,null,1,null,g)),S._3(1,16384,null,0,B.k,[S.N,S.K],{ngIf:[0,"ngIf"]},null),(e()(),S._25(-1,null,["\n"])),(e()(),S._4(3,0,null,null,4,"ul",[["class","section-list"]],null,null,null,null,null)),(e()(),S._25(-1,null,["\n  "])),(e()(),S.Z(16777216,null,null,1,null,y)),S._3(6,802816,null,0,B.j,[S.N,S.K,S.q],{ngForOf:[0,"ngForOf"]},null),(e()(),S._25(-1,null,["\n"])),(e()(),S._25(-1,null,["\n"]))],function(e,t){var n=t.component;e(t,1,0,null==n.relatedOperators?null:n.relatedOperators.length),e(t,6,0,n.relatedOperators)},null)}function x(e){return S._27(0,[(e()(),S._4(0,0,null,null,4,"li",[],null,null,null,null,null)),(e()(),S._25(-1,null,["\n    "])),(e()(),S._4(2,0,null,null,1,"a",[["target","_blank"]],[[8,"href",4]],null,null,null,null)),(e()(),S._25(3,null,[" "," "])),(e()(),S._25(-1,null,["\n  "]))],null,function(e,t){e(t,2,0,t.context.$implicit.url),e(t,3,0,t.context.$implicit.description)})}function k(e){return S._27(0,[(e()(),S._4(0,0,null,null,1,"h2",[],null,null,null,null,null)),(e()(),S._25(-1,null,[" Additional Resources "])),(e()(),S._25(-1,null,["\n"])),(e()(),S._4(3,0,null,null,16,"ul",[["class","section-list"]],null,null,null,null,null)),(e()(),S._25(-1,null,["\n  "])),(e()(),S._4(5,0,null,null,4,"li",[],null,null,null,null,null)),(e()(),S._25(-1,null,["\n    "])),(e()(),S._4(7,0,null,null,1,"a",[["target","_blank"]],[[8,"href",4]],null,null,null,null)),(e()(),S._25(-1,null,[" Source Code "])),(e()(),S._25(-1,null,["\n  "])),(e()(),S._25(-1,null,["\n  "])),(e()(),S._4(11,0,null,null,4,"li",[],null,null,null,null,null)),(e()(),S._25(-1,null,["\n    "])),(e()(),S._4(13,0,null,null,1,"a",[["target","_blank"]],[[8,"href",4]],null,null,null,null)),(e()(),S._25(-1,null,[" Specs "])),(e()(),S._25(-1,null,["\n  "])),(e()(),S._25(-1,null,["\n  "])),(e()(),S.Z(16777216,null,null,1,null,x)),S._3(18,802816,null,0,B.j,[S.N,S.K,S.q],{ngForOf:[0,"ngForOf"]},null),(e()(),S._25(-1,null,["\n"])),(e()(),S._25(-1,null,["\n"]))],function(e,t){e(t,18,0,t.component.additionalResources)},function(e,t){var n=t.component;e(t,7,0,n.sourceUrl),e(t,13,0,n.specsUrl)})}function w(e){return S._27(0,[(e()(),S._4(0,0,null,null,2,"app-operator-extras",[["class","margin-bottom-16"]],null,null,null,u,re)),S._3(1,49152,null,0,ne,[],{operatorExtras:[0,"operatorExtras"]},null),(e()(),S._25(-1,null,["\n  "]))],function(e,t){e(t,1,0,t.component.shortDescriptionExtras)},null)}function _(e){return S._27(0,[(e()(),S._4(0,0,null,null,2,"app-operator-parameters",[],null,null,null,p,oe)),S._3(1,49152,null,0,ae,[],{operatorParameters:[0,"operatorParameters"]},null),(e()(),S._25(-1,null,["\n  "]))],function(e,t){e(t,1,0,t.component.parameters)},null)}function T(e){return S._27(0,[(e()(),S._4(0,0,null,null,2,"app-operator-extras",[["class","margin-bottom-16"]],null,null,null,u,re)),S._3(1,49152,null,0,ne,[],{operatorExtras:[0,"operatorExtras"]},null),(e()(),S._25(-1,null,["\n  "]))],function(e,t){e(t,1,0,t.component.walkthroughExtras)},null)}function j(e){return S._27(0,[(e()(),S._4(0,0,null,null,2,"app-operator-header",[["class","operator-header"]],[[8,"id",0]],null,null,b,ue)),S._3(1,49152,null,0,ie,[],{operatorName:[0,"operatorName"],operatorSignature:[1,"operatorSignature"]},null),(e()(),S._25(-1,null,["\n"])),(e()(),S._25(-1,null,["\n"])),(e()(),S._4(4,0,null,null,33,"section",[["class","main-operator-container mat-typography"]],null,null,null,null,null)),(e()(),S._25(-1,null,["\n  "])),(e()(),S._4(6,0,null,null,1,"h3",[["class","short-description"]],[[8,"innerHTML",1]],null,null,null,null)),(e()(),S._25(-1,null,["\n  "])),(e()(),S._25(-1,null,["\n  "])),(e()(),S.Z(16777216,null,null,1,null,w)),S._3(10,16384,null,0,B.k,[S.N,S.K],{ngIf:[0,"ngIf"]},null),(e()(),S._25(-1,null,["\n  "])),(e()(),S._4(12,0,null,null,2,"app-marble-diagram",[["class","margin-bottom-32"]],null,null,null,d,pe)),S._3(13,49152,null,0,ce,[],{operatorName:[0,"operatorName"],useInteractiveMarbles:[1,"useInteractiveMarbles"],url:[2,"url"]},null),(e()(),S._25(-1,null,["\n  "])),(e()(),S._25(-1,null,["\n  "])),(e()(),S._4(16,0,null,null,2,"app-operator-examples",[["class","margin-bottom-16"]],null,[[null,"copyToClipboard"]],function(e,t,n){var r=!0;return"copyToClipboard"===t&&(r=!1!==e.component.copyToClipboard(n)&&r),r},f,ye)),S._3(17,49152,null,0,ge,[],{operatorExamples:[0,"operatorExamples"]},{copyToClipboard:"copyToClipboard"}),(e()(),S._25(-1,null,["\n  "])),(e()(),S._25(-1,null,["\n  "])),(e()(),S.Z(16777216,null,null,1,null,_)),S._3(21,16384,null,0,B.k,[S.N,S.K],{ngIf:[0,"ngIf"]},null),(e()(),S._25(-1,null,["\n  "])),(e()(),S._4(23,0,null,null,2,"app-operator-walkthrough",[["class","margin-bottom-16"]],null,null,null,v,xe)),S._3(24,49152,null,0,Oe,[],{operatorWalkthrough:[0,"operatorWalkthrough"]},null),(e()(),S._25(-1,null,["\n  "])),(e()(),S._25(-1,null,["\n  "])),(e()(),S.Z(16777216,null,null,1,null,T)),S._3(28,16384,null,0,B.k,[S.N,S.K],{ngIf:[0,"ngIf"]},null),(e()(),S._25(-1,null,["\n  "])),(e()(),S._4(30,0,null,null,2,"app-related-operators",[],null,null,null,O,we)),S._3(31,49152,null,0,ke,[],{relatedOperators:[0,"relatedOperators"]},null),(e()(),S._25(-1,null,["\n  "])),(e()(),S._25(-1,null,["\n  "])),(e()(),S._4(34,0,null,null,2,"app-additional-resources",[],null,null,null,k,Te)),S._3(35,49152,null,0,_e,[],{additionalResources:[0,"additionalResources"],sourceUrl:[1,"sourceUrl"],specsUrl:[2,"specsUrl"]},null),(e()(),S._25(-1,null,["\n  "])),(e()(),S._25(-1,null,["\n"])),(e()(),S._25(-1,null,["\n"]))],function(e,t){var n=t.component;e(t,1,0,n.operatorName,n.signature),e(t,10,0,n.shortDescriptionExtras),e(t,13,0,n.operatorName,n.useInteractiveMarbles,n.marbleUrl),e(t,17,0,n.examples),e(t,21,0,null==n.parameters?null:n.parameters.length),e(t,24,0,n.walkthrough),e(t,28,0,n.walkthroughExtras),e(t,31,0,n.relatedOperators),e(t,35,0,n.additionalResources,n.sourceUrl,n.specsUrl)},function(e,t){var n=t.component;e(t,0,0,n.operatorName),e(t,6,0,n.shortDescription)})}Object.defineProperty(t,"__esModule",{value:!0});var S=n("LMZF"),R=[{name:"combineAll",operatorType:"combination",signature:"public combineAll(project: function): Observable",parameters:[{name:"project",type:"function",attribute:"optional",description:"An optional function to map the most recent values from each inner Observable into a new result.\n      Takes each of the most recent values from each collected inner Observable as arguments, in order."}],marbleUrl:"http://reactivex.io/rxjs/img/combineAll.png",shortDescription:{description:'\n      Flattens an Observable-of-Observables by applying <a href="/#/operators/combineLatest" class="markdown-code">combineLatest</a>\n      when the Observable-of-Observables completes.',extras:[]},walkthrough:{description:'\n      <p>\n        Takes an Observable of Observables, and collects all Observables from it.\n        Once the outer Observable completes, it subscribes to all collected\n        Observables and combines their values using the <a href="/#/operators/combineLatest" class="markdown-code">combineLatest</a>\n        strategy, such that:\n      </p>\n      <ul>\n        <li>Every time an inner Observable emits, the output Observable emits.</li>\n        <li>When the returned observable emits, it emits all of the latest values by:\n          <ul>\n            <li>\n              If a <span class="markdown-code">project</span> function is provided, it is called with each recent value\n              from each inner Observable in whatever order they arrived, and the result\n              of the <span class="markdown-code">project</span> function is what is emitted by the output Observable.\n            </li>\n            <li>\n              If there is no <span class="markdown-code">project</span> function, an array of all of the most recent\n              values is emitted by the output Observable.\n            </li>\n          </ul>\n        </li>\n      </ul>\n    '},examples:[{name:'Map two click events to a finite interval Observable, then apply <span class="markdown-code">combineAll</span>',code:"\n        const clicks = Rx.Observable.fromEvent(document, 'click');\n        const higherOrder = clicks.map(ev =>\n          Rx.Observable.interval(Math.random()*2000).take(3)\n        )\n        .take(2);\n        const result = higherOrder.combineAll();\n        result.subscribe(x => console.log(x));\n      ",externalLink:{platform:"JSBin",url:"http://jsbin.com/peparawuvo/1/embed?js,console,output"}}],relatedOperators:["combineLatest","mergeAll"],additionalResources:[]},{name:"combineLatest",operatorType:"combination",signature:"public combineLatest(observables: ...Observable, project: function): Observable",useInteractiveMarbles:!0,parameters:[{name:"other",type:"Observable",attribute:"",description:"An input Observable to combine with the source Observable. More than one input Observables may be given as argument."},{name:"other",type:"function",attribute:"optional",description:"An optional function to project the values from the combined latest values into a new value on the output Observable."}],marbleUrl:"http://reactivex.io/rxjs/img/combineLatest.png",shortDescription:{description:"\n      Combines multiple Observables to create an Observable whose values\n      are calculated from the latest values of each of its input Observables.\n    ",extras:[{type:"Tip",text:'\n          Note: combineLatest will only start to emit when all sources have emitted at least once. By adding a default\n           start value to the sources with <a href="#/operators/startWith" class="markdown-code">startWith</a>, it will activate right away.\n         '}]},walkthrough:{description:'\n      <p>\n        <span class="markdown-code">combineLatest</span> combines the values from this Observable with values from\n        Observables passed as arguments. This is done by subscribing to each\n        Observable, in order, and collecting an array of each of the most recent\n        values any time any of the input Observables emits, then either taking that\n        array and passing it as arguments to an optional <span class="markdown-code">project</span> function and\n        emitting the return value of that, or just emitting the array of recent\n        values directly if there is no <span class="markdown-code">project</span> function.\n      </p>\n    '},examples:[{name:"Dynamically calculate the Body-Mass Index from an Observable of weight and one for height",code:"\n        const weight = Rx.Observable.of(70, 72, 76, 79, 75);\n        const height = Rx.Observable.of(1.76, 1.77, 1.78);\n        const bmi = weight.combineLatest(height, (w, h) => w / (h * h));\n        /*\n           Output:\n           BMI is 24.212293388429753\n           BMI is 23.93948099205209\n           BMI is 23.671253629592222\n        */\n        bmi.subscribe(x => console.log('BMI is ' + x));\n      ",externalLink:{platform:"JSBin",url:"http://jsbin.com/pivowunedu/1/embed?js,console"}}],relatedOperators:["combineAll","merge","withLatestFrom"],additionalResources:[]},{name:"concat",operatorType:"combination",signature:"public static concat(input1: ObservableInput, input2: ObservableInput, scheduler: Scheduler): Observable",parameters:[{name:"input1",type:"ObservableInput",attribute:"",description:"An input Observable to concatenate with others."},{name:"input2",type:"ObservableInput",attribute:"",description:"An input Observable to concatenate with others. More than one input Observables may be given as argument."},{name:"scheduler",type:"Scheduler",attribute:"optional default: null",description:"An optional IScheduler to schedule each Observable subscription on."}],marbleUrl:"http://reactivex.io/rxjs/img/concat.png",shortDescription:{description:"Creates an output Observable which sequentially emits all values from given Observable and then moves on to the next.",extras:[{type:"Tip",text:"Concatenates multiple Observables together by sequentially emitting their values, one Observable after the other."}]},walkthrough:{description:"\n      <p><span class='markdown-code'>concat</span> joins multiple Observables together, by subscribing to them one at a time and\n      merging their results into the output Observable. You can pass either an array of\n      Observables, or put them directly as arguments. Passing an empty array will result\n      in Observable that completes immediately.</p>\n\n      <p><span class='markdown-code'>concat</span> will subscribe to first input Observable and emit all its values, without\n      changing or affecting them in any way. When that Observable completes, it will\n      subscribe to then next Observable passed and, again, emit its values. This will be\n      repeated, until the operator runs out of Observables. When last input Observable completes,\n      <span class='markdown-code'>concat</span> will complete as well. At any given moment only one Observable passed to operator\n      emits values. If you would like to emit values from passed Observables concurrently, check out\n      <a href='/#/operators/merge' class='markdown-code'>merge</a> instead, especially with optional\n      <span class='markdown-code'>concurrent</span> parameter.\n      As a matter of fact, <span class='markdown-code'>concat</span> is an equivalent of\n      <a href='/#/operators/merge' class='markdown-code'>merge</a> operator with\n      <span class='markdown-code'>concurrent</span> parameter set to <span class='markdown-code'>1</span>.</p>\n\n      <p>Note that if some input Observable never completes, <span class='markdown-code'>concat</span> will also never complete\n      and Observables following the one that did not complete will never be subscribed. On the other\n      hand, if some Observable simply completes immediately after it is subscribed, it will be\n      invisible for <span class='markdown-code'>concat</span>, which will just move on to the next Observable.</p>\n\n      <p>If any Observable in chain errors, instead of passing control to the next Observable,\n      <span class='markdown-code'>concat</span> will error immediately as well. Observables that would be subscribed after\n      the one that emitted error, never will.</p>\n\n      <p>If you pass to <span class='markdown-code'>concat</span> the same Observable many times, its stream of values\n      will be 'replayed' on every subscription, which means you can repeat given Observable\n      as many times as you like. If passing the same Observable to <span class='markdown-code'>concat</span> 1000 times becomes tedious,\n      you can always use <span class='markdown-code'>repeat</span>.</p>\n    "},examples:[{name:"Concatenate a timer counting from 0 to 3 with a synchronous sequence from 1 to 10",code:"\n      const timer = Rx.Observable.interval(1000).take(4);\n      const sequence = Rx.Observable.range(1, 10);\n      const result = Rx.Observable.concat(timer, sequence);\n      result.subscribe(x => console.log(x));\n\n      // results in:\n      // 0 -1000ms-> 1 -1000ms-> 2 -1000ms-> 3 -immediate-> 1 ... 10\n    ",externalLink:{platform:"JSBin",url:"http://jsbin.com/doqoyimaxu/embed?js,console"}},{name:"Concatenate an array of 3 Observables",code:"\n      const timer1 = Rx.Observable.interval(1000).take(10);\n      const timer2 = Rx.Observable.interval(2000).take(6);\n      const timer3 = Rx.Observable.interval(500).take(10);\n      const result = timer1.concat(timer2, timer3);\n      result.subscribe(x => console.log(x));\n\n      // results in the following:\n      // (Prints to console sequentially)\n      // -1000ms-> 0 -1000ms-> 1 -1000ms-> ... 9\n      // -2000ms-> 0 -2000ms-> 1 -2000ms-> ... 5\n      // -500ms-> 0 -500ms-> 1 -500ms-> ... 9\n    ",externalLink:{platform:"JSBin",url:"http://jsbin.com/decaromone/1/embed?js,console"}}],relatedOperators:["concatAll","concatMap","concatMapTo"]},{name:"concatAll",operatorType:"combination",signature:"public concatAll(): Observable",parameters:[],marbleUrl:"http://reactivex.io/rxjs/img/concatAll.png",shortDescription:{description:"Converts a higher-order Observable into a first-order Observable by concatenating the inner Observables in order.",extras:[{type:"Tip",text:"Flattens an Observable-of-Observables by putting one inner Observable after the other."}]},walkthrough:{description:"\n      Joins every Observable emitted by the source (a higher-order Observable), in a serial fashion.\n      It subscribes to each inner Observable only after the previous inner Observable has completed,\n      and merges all of their values into the returned observable.\n    ",extras:[{type:"Warning",text:"\n        If the source Observable emits Observables quickly and endlessly, and the inner Observables it emits generally\n        complete slower than the source emits, you can run into memory issues as the incoming Observables collect in an unbounded buffer.\n      "},{type:"Tip",text:"concatAll is equivalent to mergeAll with concurrency parameter set to 1."}]},examples:[{name:"For each click event, tick every second from 0 to 3, with no concurrency",code:"\n        const clicks = Rx.Observable.fromEvent(document, 'click');\n        const higherOrder = clicks.map(ev => Rx.Observable.interval(1000).take(4));\n        const firstOrder = higherOrder.concatAll();\n        firstOrder.subscribe(x => console.log(x));\n      ",externalLink:{platform:"JSBin",url:"http://jsbin.com/guhefeyahi/embed?js,console,output"}}],relatedOperators:["combineAll","concat","concatMap","concatMapTo","exhaust","mergeAll","switch","zipAll"],additionalResources:[]},{name:"forkJoin",operatorType:"combination",signature:"public static forkJoin(sources: *): any",parameters:[{name:"sources",type:"*",attribute:"",description:""}],marbleUrl:"http://reactivex.io/rxjs/img/forkJoin.png",shortDescription:{description:"Joins last values emitted by passed Observables.",extras:[{type:"Tip",text:"Wait for Observables to complete and then combine last values they emitted."}]},walkthrough:{description:'\n      <p>\n        <span class="markdown-code">forkJoin</span> is an operator that takes any number of\n        Observables which can be passed either as an array or directly as arguments. If no input\n        Observables are provided, resulting stream will complete immediately.\n      </p>\n      <p>\n        <span class="markdown-code">forkJoin</span> will wait for all passed Observables to complete\n        and then it will emit an array with last values from corresponding Observables. So if you\n        pass "n" Observables to the operator, resulting array will have "n" values, where first\n        value is the last thing emitted by the first Observable, second value is the last thing\n        emitted by the second Observable and so on. That means <span class="markdown-code">forkJoin</span> will\n        not emit more than once and it will complete after that. If you need to emit combined values not only\n        at the end of lifecycle of passed Observables, but also throughout it, try out\n        <a href=\'/#/operators/combineLatest\' class=\'markdown-code\'>combineLatest</a>\n        or <a href=\'/#/operators/zip\' class=\'markdown-code\'>zip</a> instead.\n      </p>\n      <p>\n        In order for resulting array to have the same length as the number of input Observables, whenever any of that\n        Observables completes without emitting any value,\n        <span class="markdown-code">forkJoin</span> will complete at that moment as well and it will not\n        emit anything either, even if it already has some last values from other Observables.\n      </p>\n\n      <p>\n        Conversely, if there is an Observable that never completes,\n        <span class="markdown-code">forkJoin</span> will never complete as well, unless at\n        any point some other Observable completes without emitting value, which brings us back to the previous case.\n        Overall, in order for <span class="markdown-code">forkJoin</span> to emit a value, all Observables passed as arguments\n        have to emit something at least once and complete.\n      </p>\n      <p>\n        If any input Observable errors at some point, <span class="markdown-code">forkJoin</span>\n        will error as well and all other Observables\n        will be immediately unsubscribed.\n      </p>\n      <p>\n        Optionally <span class="markdown-code">forkJoin</span> accepts project function, that will be\n        called with values which normally would land in emitted array. Whatever is returned by project function,\n        will appear in output Observable instead. This means that default project can be thought of as a\n        function that takes all its arguments and puts them into an array. Note that project function will be called only\n        when output Observable is supposed to emit a result.\n      </p>\n    '},examples:[{name:"Use forkJoin with operator emitting immediately",code:"\n      const observable = Rx.Observable.forkJoin(\n        Rx.Observable.of(1, 2, 3, 4),\n        Rx.Observable.of(5, 6, 7, 8)\n      );\n      observable.subscribe(\n        value => console.log(value),\n        err => {},\n        () => console.log('This is how it ends!')\n      );\n      // Logs:\n      // [4, 8]\n      // \"This is how it ends!\"\n    ",externalLink:{platform:"JSBin",url:"http://jsbin.com/kinilaruki/1/embed?js,console"}},{name:"Use forkJoin with operator emitting after some time",code:"\n      const observable = Rx.Observable.forkJoin(\n        Rx.Observable.interval(1000).take(3), // emit 0, 1, 2 every second and complete\n        Rx.Observable.interval(500).take(4) // emit 0, 1, 2, 3 every half a second and complete\n      );\n      observable.subscribe(\n        value => console.log(value),\n        err => {},\n        () => console.log('This is how it ends!')\n      );\n      // Logs:\n      // [2, 3] after 3 seconds\n      // \"This is how it ends!\" immediately after\n    ",externalLink:{platform:"JSBin",url:"http://jsbin.com/rewivubuqi/1/embed?js,console"}},{name:"Use forkJoin with project function",code:"\n      const observable = Rx.Observable.forkJoin(\n        Rx.Observable.interval(1000).take(3), // emit 0, 1, 2 every second and complete\n        Rx.Observable.interval(500).take(4), // emit 0, 1, 2, 3 every half a second and complete\n        (n, m) => n + m\n      );\n      observable.subscribe(\n        value => console.log(value),\n        err => {},\n        () => console.log('This is how it ends!')\n      );\n      // Logs:\n      // 5 after 3 seconds\n      // \"This is how it ends!\" immediately after\n    ",externalLink:{platform:"JSBin",url:"http://jsbin.com/wayomumike/1/embed?js,console"}}],relatedOperators:["combineLatest","zip"]},{name:"merge",operatorType:"combination",signature:"public merge(other: ObservableInput, concurrent: number, scheduler: Scheduler): Observable",parameters:[{name:"other",type:"ObservableInput",attribute:"",description:"An input Observable to merge with the source Observable. More than one input\n       Observables may be given as argument."},{name:"concurrent",type:"number",attribute:"optional, default: Number.POSITIVE_INFINITY",description:"Maximum number of input Observables being subscribed to concurrently."},{name:"scheduler",type:"Scheduler",attribute:"optional, default: null",description:"The IScheduler to use for managing concurrency of input Observables."}],marbleUrl:"http://reactivex.io/rxjs/img/merge.png",shortDescription:{description:'Creates an output Observable which concurrently emits all values\n      from every given input Observable. <span class="informal">Flattens multiple Observables\n      together by blending their values into one Observable.</span>'},walkthrough:{description:'\n      <p><span class="markdown-code">Merge</span> subscribes to each given input Observable (either the source or an\n      Observable given as argument), and simply forwards (without doing any\n      transformation) all the values from all the input Observables to the output\n      Observable. The output Observable only completes once all input Observables\n      have completed. Any error delivered by an input Observable will be immediately\n      emitted on the output Observable.</p>\n    '},examples:[{name:"Merge together two Observables: 1s interval and clicks",code:"\n        const clicks = Rx.Observable.fromEvent(document, 'click');\n        const timer = Rx.Observable.interval(1000);\n        const clicksOrTimer = clicks.merge(timer);\n        clicksOrTimer.subscribe(x => console.log(x));\n      ",externalLink:{platform:"JSBin",url:"http://jsbin.com/wihafapiva/1/embed?js,output"}},{name:"Merge together 3 Observables, but only 2 run concurrently",code:"\n        const timer1 = Rx.Observable.interval(1000).take(10);\n        const timer2 = Rx.Observable.interval(2000).take(6);\n        const timer3 = Rx.Observable.interval(500).take(10);\n        const concurrent = 2; // the argument\n        const merged = timer1.merge(timer2, timer3, concurrent);\n        merged.subscribe(x => console.log(x));\n      ",externalLink:{platform:"JSBin",url:"http://jsbin.com/midosuqaga/1/embed?js,output"}}],relatedOperators:["mergeAll","mergeMap","mergeMapTo","mergeScan"]},{name:"mergeAll",operatorType:"combination",signature:"public mergeAll(concurrent: number): Observable",parameters:[{name:"concurrent",type:"number",attribute:"optional, default: Number.POSITIVE_INFINITY",description:"Maximum number of input Observables being subscribed to concurrently."}],marbleUrl:"http://reactivex.io/rxjs/img/mergeAll.png",shortDescription:{description:"Converts a higher-order Observable into a first-order Observable which concurrently\n     delivers all values that are emitted on the inner Observables",extras:[{type:"Tip",text:"Flattens an Observable-of-Observables."}]},walkthrough:{description:'\n      <p><span class="markdown-code">MergeAll</span> subscribes to an Observable that emits Observables,\n        also known as a higher-order Observable. Each time it observes one of these emitted\n        inner Observables, it subscribes to that and delivers all the values from the inner\n        Observable on the output Observable. The output Observable only completes once all inner\n        Observables have completed. Any error delivered by a inner Observable will be immediately\n        emitted on the output Observable.</p>\n    '},examples:[{name:"Spawn a new interval Observable for each click event, and blend their outputs as one Observable",code:"\n        const clicks = Rx.Observable.fromEvent(document, 'click');\n        const higherOrder = clicks.map((ev) => Rx.Observable.interval(1000));\n        const firstOrder = higherOrder.mergeAll();\n        firstOrder.subscribe(x => console.log(x));\n      ",externalLink:{platform:"JSBin",url:"http://jsbin.com/lebidefocu/1/embed?js,output"}},{name:"Count from 0 to 9 every second for each click, but only allow 2 concurrent timers",code:"\n        const clicks = Rx.Observable.fromEvent(document, 'click');\n        const higherOrder = clicks.map((ev) => Rx.Observable.interval(1000).take(10));\n        const firstOrder = higherOrder.mergeAll(2);\n        firstOrder.subscribe(x => console.log(x));\n      ",externalLink:{platform:"JSBin",url:"http://jsbin.com/kokezoribu/embed?js,output"}}],relatedOperators:["combineAll","concatAll","exhaust","merge","mergeMap","mergeMapTo","mergeScan","switch","zipAll"]},{name:"pairwise",operatorType:"combination",marbleUrl:"http://reactivex.io/rxjs/img/pairwise.png",signature:"public pairwise(): Observable<Array<T>>",shortDescription:{description:"Groups pairs of consecutive emissions together and emits them as an array of two values.",extras:[{type:"Tip",text:"Puts the current value and previous value together as an array, and emits that."}]},walkthrough:{description:"\n      <p>The Nth emission from the source Observable will cause the output Observable\n      to emit an array [(N-1)th, Nth] of the previous and the current value, as a\n      pair. For this reason, <code>pairwise</code> emits on the second and subsequent\n      emissions from the source Observable, but not on the first emission, because\n      there is no previous value in that case.</p>\n    "},examples:[{name:"On every click (starting from the second), emit the relative distance to the previous click",code:"\n      const clicks = Rx.Observable.fromEvent(document, 'click');\n      const pairs = clicks.pairwise();\n      const distance = pairs.map(pair => {\n        const x0 = pair[0].clientX;\n        const y0 = pair[0].clientY;\n        const x1 = pair[1].clientX;\n        const y1 = pair[1].clientY;\n        return Math.sqrt(Math.pow(x0 - x1, 2) + Math.pow(y0 - y1, 2));\n      });\n      distance.subscribe(x => console.log(x));\n    ",externalLink:{platform:"JSBin",url:"http://jsbin.com/wenazagegu/embed?js,console,output"}}],relatedOperators:["buffer","bufferCount"]},{name:"race",operatorType:"combination"},{name:"startWith",operatorType:"combination",marbleUrl:"http://reactivex.io/rxjs/img/startWith.png",signature:"public startWith(values: ...T, scheduler: Scheduler): Observable",shortDescription:{description:"Returns an Observable that emits the items you specify as arguments before it begins to emit items emitted by the source Observable."},parameters:[{name:"values",type:"...T",attribute:"",description:"Items you want the modified Observable to emit first."},{name:"scheduler",type:"Scheduler",attribute:"optional",description:"A IScheduler to use for scheduling the emissions of the next notifications."}]},{name:"withLatestFrom",operatorType:"combination",signature:"public withLatestFrom(other: ObservableInput, project: Function): Observable",marbleUrl:"http://reactivex.io/rxjs/img/withLatestFrom.png",shortDescription:{description:"Combines the source Observable with other Observables to create an Observable whose values are\n      calculated from the latest values of each, only when the source emits.",extras:[{type:"Tip",text:"Whenever the source Observable emits a value, it computes a formula using that\n      value plus the latest values from other input Observables, then emits the output of that formula."}]},walkthrough:{description:'\n        <p><span class="markdown-code">withLatestFrom</span> combines each value from the source Observable (the instance) with the latest\n        values from the other input Observables only when the source emits a value, optionally using\n        a project function to determine the value to be emitted on the output Observable. All input\n        Observables must emit at least one value before the output Observable will emit a value.\n        </p>\n      '},examples:[{name:"For each click event, tick every second from 0 to 3, with no concurrency",code:"\n        const clicks = Rx.Observable.fromEvent(document, 'click');\n        const higherOrder = clicks.map(ev => Rx.Observable.interval(1000).take(4));\n        const firstOrder = higherOrder.concatAll();\n        firstOrder.subscribe(x => console.log(x));\n      ",externalLink:{platform:"JSBin",url:"http://jsbin.com/wojoqenitu/1/embed?js,console,output"}}],relatedOperators:["combineLatest"]},{name:"zip",operatorType:"combination"}].concat([{name:"defaultIfEmpty",operatorType:"conditional"},{name:"every",operatorType:"conditional"}],[{name:"create",operatorType:"creation"},{name:"empty",operatorType:"creation",signature:"public empty(scheduler?: IScheduler): Observable",parameters:[{name:"scheduler",type:"IScheduler",attribute:"optional",description:"Allows scheduling the emission of the complete notification."}],marbleUrl:"http://reactivex.io/rxjs/img/empty.png",shortDescription:{description:"Creates an Observable that emits no items to the Observer and immediately emits a complete notification."},walkthrough:{description:"This static operator is useful for creating a simple\n       Observable that only emits the complete notification. It can be used for\n       composing with other Observables"},examples:[{name:"Observable completes immediately",code:"const observable = Rx.Observable.empty();\n             const subscription = observable.subscribe({\n               next: () => console.log('next'), // does not log anything\n               complete: () => console.log('complete'), // logs 'complete'\n             });",externalLink:{platform:"JSBin",url:"http://jsbin.com/hojacunecu/1/embed?js,console,output"}},{name:"Observable emits initial value then completes",code:"const observable = Rx.Observable.empty().startWith('initial value');\n             const subscription = observable.subscribe({\n               next: (val) => console.log(`next: ${val}`), // logs 'next: initial value'\n               complete: () => console.log('complete'), // logs 'complete'\n             });",externalLink:{platform:"JSBin",url:"http://jsbin.com/tubonoradi/1/embed?js,console,output"}},{name:"Map and flatten only odd numbers to the sequence 'ax', 'bx', 'cx'",code:"const source = Rx.Observable.of(1, 2, 3, 4, 5, 6, 7, 8, 9);\n             const result = source.mergeMap(\n               x => x % 2 === 1 ? Rx.Observable.of(`a${x}`, `b${x}`, `c${x}`) :\n                                  Rx.Observable.empty()\n             );\n             const subscription = result.subscribe({\n               next: (x) => console.log(x), // logs result values\n               complete: () => console.log('complete'), // logs 'complete'\n             });",externalLink:{platform:"JSBin",url:"http://jsbin.com/qazabojiri/embed?js,console,output"}}],relatedOperators:["create","of","throw"]},{name:"from",operatorType:"creation",signature:"from(ish: ArrayLike | ObservableInput, scheduler: Scheduler): Observable",parameters:[{name:"ish",type:"ArrayLike | ObservableInput",attribute:"",description:"A subscribable object, a Promise, an  Observable-like, an Array, an\n\t  iterable or an array-like object to be converted."},{name:"scheduler",type:"Scheduler",attribute:"optional",description:"The scheduler on which to schedule the emissions of values."}],marbleUrl:"http://reactivex.io/rxjs/img/from.png",shortDescription:{description:'Creates an Observable from an Array, an array-like object, a Promise, an\n    iterable object, or an Observable-like object.\n    <span class="informal">Converts almost anything to an Observable.</span>'},walkthrough:{description:"Converts various other objects and data types into Observables. <span class=\"markdown-code\">from</span>\n    converts a Promise or an array-like or an\n    <a href ='https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols#iterable' target='_blank'>iterable</a>\n    object into an Observable that emits the items in that promise or array or\n    iterable. A String, in this context, is treated as an array of characters.\n    Observable-like objects (contains a function named with the ES2015 Symbol\n    for Observable) can also be converted through this operator.\n   "},examples:[{name:"Converts an array to an Observable",code:"\n      const array = [10, 20, 30];\n      const result = Rx.Observable.from(array);\n      result.subscribe(x => console.log(x));\n\n      // Results in the following:\n      // 10 20 30",externalLink:{platform:"JSBin",url:"http://jsbin.com/qodocay/embed?js,console"}},{name:"Convert an infinite iterable (from a generator) to an Observable",code:"\n      function* generateDoubles(seed) {\n        let i = seed;\n        while (true) {\n          yield i;\n          i = 2 * i; // double it\n        }\n      }\n      const iterator = generateDoubles(3);\n      const result = Rx.Observable.from(iterator).take(10);\n      result.subscribe(x => console.log(x));\n      // Results in the following:\n      // 3 6 12 24 48 96 192 384 768 1536",externalLink:{platform:"JSBin",url:"http://jsbin.com/kidevan/embed?js,console"}},{name:'Using <span class="markdown-code">from</span> with async scheduler',code:"\n      console.log('start');\n      const array = [10, 20, 30];\n      const result = Rx.Observable.from(array, Rx.Scheduler.async);\n      result.subscribe(x => console.log(x));\n      console.log('end');\n      // Results in the following:\n      // start end 10 20 30",externalLink:{platform:"JSBin",url:"http://jsbin.com/xunesam/embed?js,console"}}],relatedOperators:["create","fromEvent","fromEventPattern","fromPromise"]},{name:"fromEvent",operatorType:"creation"},{name:"fromPromise",operatorType:"creation"},{name:"interval",operatorType:"creation"},{name:"of",operatorType:"creation"},{name:"range",operatorType:"creation"},{name:"throw",operatorType:"creation"},{name:"timer",operatorType:"creation"}],[{name:"catch",operatorType:"error handling"},{name:"catch",operatorType:"error handling"},{name:"retryWhen",operatorType:"error handling"}],[{name:"debounce",operatorType:"filtering",signature:"public debounce(durationSelector: function(value: T): SubscribableOrPromise): Observable",marbleUrl:"http://reactivex.io/rxjs/img/debounce.png",parameters:[{name:"durationSelector",type:"function(value: T): SubscribableOrPromise",attribute:"",description:"A function that receives a value from the source Observable\n        , for computing the timeout duration for each source value, returned as an Observable or a Promise."}],shortDescription:{description:"Emits a value from the source Observable only after a particular time span determined\n       by another Observable has passed without another source emission.",extras:[{type:"Tip",text:"\n        It's like debounceTime, but the time span of emission silence is determined by a second Observable.\n        "}]},walkthrough:{description:"\n      <p>\n        debounce delays values emitted by the source Observable,\n        but drops previous pending delayed emissions if a new value arrives on the source Observable.\n        This operator keeps track of the most recent value from the source Observable,\n        and spawns a duration Observable by calling the durationSelector function.\n        The value is emitted only when the duration Observable emits a value or completes,\n        and if no other value was emitted on the source Observable since the duration Observable was spawned.\n        If a new value appears before the duration Observable emits,\n        the previous value will be dropped and will not be emitted on the output Observable.\n      </p>\n      <p>\n      Like debounceTime, this is a rate-limiting operator, and also a delay-like operator\n      since output emissions do not necessarily occur at the same time as they did on the source Observable.\n      </p>\n    "},examples:[{name:"Emit the most recent click after a burst of clicks",code:"\n        const clicks = Rx.Observable.fromEvent(document, 'click');\n        const result = clicks.debounce(() => Rx.Observable.interval(1000));\n        result.subscribe(x => console.log(x));\n      ",externalLink:{platform:"JSBin",url:"http://jsbin.com/zuyafikiqa/embed?js,console,output"}}],relatedOperators:["debounceTime","audit","delayWhen","throttle"],additionalResources:[]},{name:"debounceTime",operatorType:"filtering",signature:"public debounceTime(dueTime: number, scheduler: IScheduler = async): Observable",parameters:[{name:"dueTime",type:"number",attribute:"mandatory",description:"The timeout duration in milliseconds\n      (or the time unit determined internally by the optional scheduler) for the window of time required to\n      wait for emission silence before emitting the most recent source value."},{name:"scheduler",type:"IScheduler",attribute:"optional",description:"The IScheduler to use for managing the timers that handle the timeout for each value."}],marbleUrl:"http://reactivex.io/rxjs/img/debounceTime.png",shortDescription:{description:'\n    Emits a value from the source Observable only after a particular time span has passed without another source emission.\n    It\'s like <a class="markdown-code" href="#/operators/delay">delay</a>\n    , but passes only the most recent value from each burst of emissions.',extras:[]},walkthrough:{description:'\n      <p>\n      <span class="markdown-code">debounceTime</span> delays values emitted by the source Observable, but drops\n      previous pending delayed emissions if a new value arrives on the source\n      Observable. This operator keeps track of the most recent value from the\n      source Observable, and emits that only when <span class="markdown-code">dueTime</span> enough time has passed\n      without any other value appearing on the source Observable. If a new value\n      appears before <span class="markdown-code">dueTime</span> silence occurs, the previous value will be dropped\n      and will not be emitted on the output Observable.\n      </p>\n      <p>\n        This is a rate-limiting operator, because it is impossible for more than one\n        value to be emitted in any time window of duration <span class="markdown-code">dueTime</span>, but it is also\n        a delay-like operator since output emissions do not occur at the same time as\n        they did on the source Observable. Optionally takes a <span class="markdown-code">IScheduler</span> for\n        managing timers.\n      </p>\n    '},examples:[{name:"Emit the most recent value after a burst of value changes over a defined time",code:"\n        const search = document.querySelector('#search');\n        const output = document.querySelector('#output');\n        const searchChange$ = Rx.Observable.fromEvent(search, 'keyup');\n\n        searchChange$\n        .map(x => x.target.value)\n        .debounceTime(500)\n          .subscribe((search)=> output.textContent=search);\n      ",externalLink:{platform:"JSBin",url:"http://jsbin.com/gapobakuwu/edit?js,output"}}],relatedOperators:["auditTime","debounce","delay","sampleTime","throttleTime"],additionalResources:[]},{name:"distinctUntilChanged",operatorType:"filtering",signature:"public distinctUntilChanged(compare: function): Observable",useInteractiveMarbles:!0,parameters:[{name:"compare",type:"function",attribute:"optional",description:"Optional comparison function called to test if an item is distinct from the previous item in the source."}],marbleUrl:"http://reactivex.io/rxjs/img/distinctUntilChanged.png",shortDescription:{description:"\n    Returns an Observable that emits all items emitted by the source Observable that are distinct by comparison from the previous item.\n    ",extras:[{type:"Tip",text:'\n        <span class="markdown-code">distinctUntilChanged</span> uses\n        <a\n          href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Equality_comparisons_and_sameness"\n          target="_blank"\n          class="markdown-code">\n          ===\n        </a> comparison by default.\n       '}]},walkthrough:{description:"\n      <p>\n        This operator will compare each emitted item from the source to the previously emitted item,\n        emitting only distinct values by comparison such that:\n      </p>\n      <ul>\n        <li>\n         If a comparator function is provided, then it will be called for each item to test for whether or not that value should be emitted.\n        </li>\n        <li>\n          If a comparator function is not provided, an equality check is used by default.\n        </li>\n      </ul>\n    "},examples:[{name:"A simple example with numbers",code:"\n      Rx.Observable.of(1, 1, 2, 2, 2, 1, 1, 2, 3, 3, 4)\n       .distinctUntilChanged()\n       .subscribe(x => console.log(x));\n      ",externalLink:{platform:"JSBin",url:"http://jsbin.com/poxayavuge/embed?js,console"}},{name:"An example using a compare function",code:"\n      Rx.Observable.of(\n         { age: 4, name: 'Foo'},\n         { age: 7, name: 'Bar'},\n         { age: 5, name: 'Foo'},\n         { age: 6, name: 'Foo'}\n        )\n        .distinctUntilChanged((p, q) => p.name === q.name)\n        .subscribe(x => console.log(x));\n      ",externalLink:{platform:"JSBin",url:"http://jsbin.com/duhexuhoxo/embed?js,console"}}],relatedOperators:[],additionalResources:[]},{name:"filter",operatorType:"filtering",signature:"public filter(predicate: function(value: T, index: number): boolean, thisArg: any): Observable",parameters:[{name:"predicate",type:"function(value: T, index: number): boolean",attribute:"",description:"A function that evaluates each value emitted by the source Observable.\n         If it returns true, the value is emitted, if false the value is not passed to the output Observable.\n        The index parameter is the number i for the i-th source emission that has happened since the subscription,\n         starting from the number 0."},{name:"thisArg",type:"any",attribute:"optional",description:"An optional argument to determine the value of this in the predicate function."}],marbleUrl:"http://reactivex.io/rxjs/img/filter.png",shortDescription:{description:"Filter items emitted by the source Observable by only emitting those that satisfy a specified predicate.",extras:[{type:"Tip",text:'\n        Like\n        <a\n         target="_blank"\n         href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter">\n          Array.prototype.filter()\n        </a>,\n        it only emits a value from the source if it passes a criterion function.\n        '}]},walkthrough:{description:'\n      <p>\n        Similar to the well-known <span class="markdown-code">Array.prototype.filter</span>\n         method, this operator takes values from the source Observable,\n         passes them through a predicate function and only emits those values that yielded true.\n      </p>\n    '},examples:[{name:"Filter for even numbers",code:'\n      //emit (1,2,3,4,5)\n      const source = Rx.Observable.from([1, 2, 3, 4, 5]);\n      //filter out non-even numbers\n      const example = source.filter(num => num % 2 === 0);\n      //output: "Even number: 2", "Even number: 4"\n      const subscribe = example.subscribe(val => console.log(\'Even number: \' + val));\n      ',externalLink:{platform:"JSBin",url:"http://jsbin.com/vafogoluye/1/embed?js,console"}}],relatedOperators:["distinct","distinctUntilChanged","distinctUntilKeyChanged","ignoreElements","partition","skip"]},{name:"first",operatorType:"filtering",signature:"public first(predicate: function(value: T, index: number, source: Observable<T>):\n   boolean, resultSelector: function(value: T, index: number): R, defaultValue: R): Observable<T | R>",parameters:[{name:"predicate",type:"function(value: T, index: number, source: Observable<T>): boolean\t",attribute:"optional",description:"An optional function called with each item to test for condition matching."},{name:"resultSelector",type:"function(value: T, index: number): R",attribute:"optional",description:'\n       A function to produce the value on the output Observable based on the\n        values and the indices of the source Observable. The arguments passed to this function are:\n       value: the value that was emitted on the source.\n       index: the "index" of the value from the source.\n       '},{name:"defaultValue",type:"R",attribute:"optional",description:"The default value emitted in case no valid value was found on the source."}],marbleUrl:"http://reactivex.io/rxjs/img/first.png",shortDescription:{description:"Emits only the first value (or the first value that meets some condition) emitted by the source Observable.",extras:[{type:"Tip",text:"Emits only the first value. Or emits only the first value that passes some test."}]},walkthrough:{description:'\n     <p>\n      If called with no arguments, first emits the first value of the source Observable, then completes.\n     </p>\n     <p>\n      If called with a <span class="markdown-code">predicate</span> function,\n      <span class="markdown-code>first</code> emits the first value of the source that matches the specified condition.\n     </p>\n     <p>\n       It may also take a <span class="markdown-code">resultSelector</span> function to produce the output value from the input value,\n       and a <span class="markdown-code">defaultValue</span> to emit in case the source completes before it is able to emit a valid value.\n     </p>\n     <p>\n       Throws an error if defaultValue was not provided and a matching element is not found.\n     </p>\n     '},examples:[{name:"Emit only the X postition of first click that happens on the DOM",code:"\n       const clicks = Rx.Observable.fromEvent(document, 'click');\n       const result = clicks.first();\n       result.subscribe(x => console.log(x));\n       ",externalLink:{platform:"JSBin",url:"http://jsbin.com/zixuweg/1/embed?html,js,console,output"}},{name:"Emits only the X postition of first click that happens on a DIV",code:"\n       const clicks = Rx.Observable.fromEvent(document, 'click');\n       const result = clicks.first(ev => ev.target.tagName === 'DIV');\n       result.subscribe(x => console.log(x));\n       ",externalLink:{platform:"JSBin",url:"http://jsbin.com/yuwebew/1/embed?js,console,output"}}]},{name:"ignoreElements",operatorType:"filtering"},{name:"last",operatorType:"filtering",signature:"public last(predicate: function): Observable",useInteractiveMarbles:!0,parameters:[{name:"predicate",type:"function",attribute:"",description:"The condition any source emitted item has to satisfy."}],marbleUrl:"http://reactivex.io/rxjs/img/last.png",shortDescription:{description:"Emits only the last value emitted by the source Observable."},walkthrough:{description:'<p>\n      <span class="markdown-code">last</span> Returns an Observable that emits only the last item emitted by the source Observable.\n    </p>\n    <p>\n       It optionally takes a predicate function as a parameter,\n       in which case, rather than emitting the last item from the source Observable,\n       the resulting Observable will emit the last item from the source Observable that satisfies the predicate.\n    </p>'},examples:[{name:"Get the last number that is divisible by 3",code:"\n      const range = Rx.Observable.range(1, 10);\n      const last = range.last(x => x % 3 === 0);\n      last.subscribe(x => console.log(x));\n      // Logs below values\n      // 9\n      ",externalLink:{platform:"JSBin",url:"http://jsbin.com/reqacoselu/embed?html,js,console"}}],relatedOperators:["takeLast","first"]},{name:"sample",operatorType:"filtering",signature:"public sample(notifier: Observable<any>): Observable<T>",parameters:[{name:"notifier",type:"Observable<any>",attribute:"",description:"The Observable to use for sampling the source Observable."}],marbleUrl:"http://reactivex.io/rxjs/img/sample.png",shortDescription:{description:"Emits the most recently emitted value from the source Observable whenever another Observable, the notifier, emits.",extras:[{type:"Tip",text:"It's like sampleTime, but samples whenever the notifier Observable emits something."}]},walkthrough:{description:"\n      <p>\n       Whenever the notifier Observable emits a value or completes,\n       sample looks at the source Observable and emits whichever value it has most recently emitted since the previous sampling,\n       unless the source has not emitted anything since the previous sampling.\n      </p>\n      <p>\n       The notifier is subscribed to as soon as the output Observable is subscribed.\n      </p>\n    "},examples:[{name:"On every click, sample the value from source every 2 seconds",code:"\n      //emit value every 1s\n      const source = Rx.Observable.interval(1000);\n      //sample last emitted value from source every 2s\n      const example = source.sample(Rx.Observable.interval(2000));\n      //output: 2..4..6..8..\n      const subscribe = example.subscribe(val => console.log(val));\n      ",externalLink:{platform:"JSBin",url:"http://jsbin.com/gemebopifu/1/embed?js,console"}}],relatedOperators:["audit","debounce","sampleTime","throttle"]},{name:"single",operatorType:"filtering",signature:"public single(predicate: Function): Observable<T>",parameters:[{name:"predicate",type:"Function",attribute:"",description:"A predicate function to evaluate items emitted by the source Observable."}],marbleUrl:"http://reactivex.io/rxjs/img/single.png",shortDescription:{description:"Returns an Observable that emits the single item emitted by the source Observable\n       that matches a specified predicate, if that Observable emits one such item.\n       If the source Observable emits more than one such item or no such items, notify of an IllegalArgumentException\n       or NoSuchElementException respectively."},examples:[{name:"Emit first number passing predicate",code:"\n      //emit (1,2,3,4,5)\n      const source = Rx.Observable.from([1, 2, 3, 4, 5]);\n      //emit one item that matches predicate\n      const example = source.single(val => val === 4);\n      //output: 4\n      const subscribe = example.subscribe(val => console.log(val));\n      ",externalLink:{platform:"JSBin",url:"http://jsbin.com/solecibuza/embed?js,console"}}]},{name:"skip",operatorType:"filtering",signature:"public skip(count: Number): Observable",parameters:[{name:"count",type:"Number",attribute:"",description:"Returns an Observable that skips the first count items emitted by the source Observable."}],marbleUrl:"http://reactivex.io/rxjs/img/skip.png",shortDescription:{description:"Returns an Observable that skips the first count items emitted by the source Observable."},examples:[{name:"Skipping values before emission",code:"\n      //emit every 1s\n      const source = Rx.Observable.interval(1000);\n      //skip the first 5 emitted values\n      const example = source.skip(5);\n      //output: 5...6...7...8........\n      const subscribe = example.subscribe(val => console.log(val));\n      ",externalLink:{platform:"JSBin",url:"http://jsbin.com/hacepudabi/1/embed?js,console"}}]},{name:"skipUntil",operatorType:"filtering",signature:"public skipUntil(notifier: Observable): Observable<T>",parameters:[{name:"notifier",type:"Observable",attribute:"",description:"The second Observable that has to emit an item before\n       the source Observable's elements begin to be mirrored by the resulting Observable."}],marbleUrl:"http://reactivex.io/rxjs/img/skipUntil.png",shortDescription:{description:"Returns an Observable that skips items emitted by the source Observable until a second Observable emits an item."},examples:[{name:"Emits every 1s after 5 seconds",code:"\n      //emit every 1s\n      const source = Rx.Observable.interval(1000);\n      //skip emitted values from source until inner observable emits (6s)\n      const example = source.skipUntil(Rx.Observable.timer(6000));\n      //output: 5...6...7...8........\n      const subscribe = example.subscribe(val => console.log(val));\n      ",externalLink:{platform:"JSBin",url:"http://jsbin.com/tapizososu/embed?js,console,output"}}]},{name:"skipWhile",operatorType:"filtering"},{name:"take",operatorType:"filtering",signature:"public take(count: number): Observable<T>",useInteractiveMarbles:!0,parameters:[{name:"count",type:"number",attribute:"",description:"The maximum number of next values to emit."}],marbleUrl:"http://reactivex.io/rxjs/img/take.png",shortDescription:{description:"Emits only the first count values emitted by the source Observable.",extras:[{type:"Tip",text:"Takes the first count values from the source, then completes."}]},walkthrough:{description:'<p>\n      <span class="markdown-code">take</span> returns an Observable that emits only the first count values emitted by the source Observable.\n    </p>\n    <p>\n      If the source emits fewer than count values then all of its values are emitted.\n      After that, it completes, regardless if the source completes.\n    </p>'},examples:[{name:"Take the first 5 seconds of an infinite 1-second interval Observable",code:"\n      const interval = Rx.Observable.interval(1000);\n      const five = interval.take(5);\n      five.subscribe(x => console.log(x));\n      // Logs below values\n      // 0\n      // 1\n      // 2\n      // 3\n      // 4\n      ",externalLink:{platform:"JSBin",url:"http://jsbin.com/yujema/embed?html,js,console"}}],relatedOperators:["takeLast","takeUntil","takeWhile","skip"]},{name:"takeUntil",operatorType:"filtering",signature:"public takeUntil(notifier: Observable): Observable<T>",useInteractiveMarbles:!0,parameters:[{name:"notifier",type:"Observable",attribute:"",description:"The Observable whose first emitted value will cause the output Observable of takeUntil\n      to stop emitting values from the source Observable."}],marbleUrl:"http://reactivex.io/rxjs/img/takeUntil.png",shortDescription:{description:"Emits the values emitted by the source Observable until a notifier Observable emits a value.",extras:[{type:"Tip",text:"\n          Lets values pass until a second Observable, notifier, emits something. Then, it completes.\n        "}]},walkthrough:{description:"\n    <p>\n      <code>takeUntil</code> subscribes and begins mirroring the source Observable.\n    </p>\n    <p>\n      It also monitors a second Observable, notifier that you provide.\n      If the notifier emits a value or a complete notification, the output Observable stops mirroring the source Observable and completes.\n    </p>\n\n    "},examples:[{name:"Tick every second until the first click happens",code:"\n      const interval = Rx.Observable.interval(1000);\n      const clicks = Rx.Observable.fromEvent(document, 'click');\n      const result = interval.takeUntil(clicks);\n      result.subscribe(x => console.log(x));\n\n      // Logs the number of seconds since the stream started.\n      // Stream will end as soon as a click action is performed\n      // anywhere in the document\n\n      // 1\n      // 2\n      // 3\n      // ...\n      ",externalLink:{platform:"JSBin",url:"http://jsbin.com/rujeci/embed?html,js,console,output"}}],relatedOperators:["take","takeLast","takeWhile","skip"]},{name:"takeWhile",operatorType:"filtering"},{name:"throttle",operatorType:"filtering",signature:"public throttle(durationSelector: function(value: T): SubscribableOrPromise): Observable<T>",parameters:[{name:"durationSelector",type:"function(value: T): SubscribableOrPromise",attribute:"",description:"\n        A function that receives a value from the source Observable, for computing the silencing duration for each source value,\n         returned as an Observable or a Promise.\n      "}],marbleUrl:"http://reactivex.io/rxjs/img/throttle.png",shortDescription:{description:"Emits a value from the source Observable, then ignores subsequent source values for a duration\n     determined by another Observable, then repeats this process.",extras:[{type:"Tip",text:"It's like throttleTime, but the silencing duration is determined by a second Observable."}]},walkthrough:{description:'\n    <p>\n      <code>throttle</code> emits the source Observable values on the output Observable when its internal timer is disabled,\n       and ignores source values when the timer is enabled. Initially, the timer is disabled.\n    </p>\n    <p>\n      As soon as the first source value arrives, it is forwarded to the output Observable,\n      and then the timer is enabled by calling the durationSelector function with the source value,\n      which returns the "duration" Observable.\n    </p>\n    <p>\n      When the duration Observable emits a value or completes,\n      the timer is disabled, and this process repeats for the next source value.\n    </p>\n    '},examples:[{name:"Emit X position of mouse click at a rate of at most one click per second",code:"\n      const clicks = Rx.Observable.fromEvent(document, 'click');\n      const result = clicks.throttle(ev => Rx.Observable.interval(1000));\n      result.subscribe(x => console.log(x.clientX));\n      ",externalLink:{platform:"JSBin",url:"http://jsbin.com/wojifil/embed?js,console,output"}}],relatedOperators:["audit","debounce","delayWhen","sample","throttleTime"]},{name:"throttleTime",operatorType:"filtering",signature:"public throttleTime(duration: number, scheduler: Scheduler): Observable<T>",parameters:[{name:"duration",type:"number",attribute:"",description:"Time to wait before emitting another value after emitting the last value,\n         measured in milliseconds or the time unit determined internally by the optional scheduler."},{name:"scheduler",type:"Scheduler",attribute:"optional default:sync",description:"The IScheduler to use for managing the timers that handle the sampling."}],marbleUrl:"http://reactivex.io/rxjs/img/throttleTime.png",shortDescription:{description:"Emits a value from the source Observable,\n        then ignores subsequent source values for duration milliseconds, then repeats this process.",extras:[{type:"Tip",text:"\n          Lets a value pass, then ignores source values for the next duration milliseconds.\n        "}]},walkthrough:{description:"\n    <p>\n      throttleTime emits the source Observable values on the output Observable when its internal timer is disabled,\n       and ignores source values when the timer is enabled. Initially, the timer is disabled.\n    </p>\n    <p>\n      As soon as the first source value arrives, it is forwarded to the output Observable, and then the timer is enabled.\n    </p>\n    <p>\n      After duration milliseconds (or the time unit determined internally by the optional scheduler) has passed, the timer is disabled,\n      and this process repeats for the next source value. Optionally takes a IScheduler for managing timers.\n    </p>\n    "},examples:[{name:"Emit X position of mouse clicks at a rate of at most one click per second",code:"\n      const clicks = Rx.Observable.fromEvent(document, 'click');\n      const result = clicks.throttleTime(1000);\n      result.subscribe(x => console.log(x.clientX));\n      ",externalLink:{platform:"JSBin",url:"http://jsbin.com/nefefeb/embed?js,console,output"}}],relatedOperators:["auditTime","debounceTime","delay","sampleTime","throttle"]}],[{name:"multicast",operatorType:"multicasting"},{name:"publish",operatorType:"multicasting"},{name:"share",operatorType:"multicasting"}],[{name:"buffer",operatorType:"transformation",signature:"public buffer(closingNotifier: Observable): Observable",useInteractiveMarbles:!0,parameters:[{name:"closingNotifier",type:"Observable",attribute:"",description:"An Observable that signals the buffer to be emitted on the output Observable."}],marbleUrl:"http://reactivex.io/rxjs/img/buffer.png",shortDescription:{description:'\n      Buffers the source Observable values until <span class="markdown-code">closingNotifier</span>\n      emits.\n    '},walkthrough:{description:'\n      <p>\n        Buffers the incoming Observable values until the given\n        <span class="markdown-code">closingNotifier</span> Observable emits a value, at which point\n        it emits the buffer on the output Observable and starts a new buffer internally,\n        awaiting the next time <span class="markdown-code">closingNotifier</span> emits.\n      </p>\n    '},examples:[{name:"On every click, emit array of most recent interval events",code:"\n        const clicks = Rx.Observable.fromEvent(document, 'click');\n        const interval = Rx.Observable.interval(1000);\n        const buffered = interval.buffer(clicks);\n        buffered.subscribe(x => console.log(x));\n      ",externalLink:{platform:"JSBin",url:"http://jsbin.com/xetemuteho/embed?js,console,output"}}],relatedOperators:["bufferCount","bufferTime","bufferToggle","bufferWhen","window"],additionalResources:[]},{name:"bufferCount",operatorType:"transformation"},{name:"bufferTime",operatorType:"transformation"},{name:"bufferToggle",operatorType:"transformation"},{name:"bufferWhen",operatorType:"transformation"},{name:"concatMap",operatorType:"transformation"},{name:"expand",operatorType:"transformation"},{name:"groupBy",operatorType:"transformation",signature:"\n    public groupBy(keySelector: (value: T) => K,\n                   elementSelector?: ((value: T) => R) | void,\n                   durationSelector?: (grouped: GroupedObservable<K, R>) => Observable<any>,\n                   subjectSelector?: () => Subject<R>)\n          : Observable<any>): OperatorFunction<T, GroupedObservable<K, R>>",parameters:[{name:"keySelector",type:"(value: T) => K",attribute:"",description:"A function that extracts the key used for grouping for each item."},{name:"elementSelector",type:"((value: T) => R) | void",attribute:"optional",description:"A function that extracts the emitted element for each item. Default is identity function."},{name:"durationSelector",type:"(grouped: GroupedObservable<K, R>) => Observable<any>",attribute:"optional",description:"A function that returns an Observable to determine how long each group should exist."},{name:"subjectSelector",type:"() => Subject<R>",attribute:"optional",description:""}],marbleUrl:"http://reactivex.io/rxjs/img/groupBy.png",shortDescription:{description:"\n      Group, according to a specified key, elements from items emitted by an Observable,\n      and emit these grouped items as GroupedObservables, one GroupedObservable per group.\n    ",extras:[]},walkthrough:{description:"\n    <p>When the Observable emits an item, a key is computed for this item with the keySelector function.</p>\n\n    <p>If a GroupedObservable for this key exists, this GroupedObservable emits. Elsewhere, a new\n    GroupedObservable for this key is created and emits.</p>\n\n    <p>A GroupedObservable represents values belonging to the same group represented by a common key.\n    The common key is available as the key field of a GroupedObservable instance.</p>\n\n    <p>The elements emitted by GroupedObservables are by default the items emitted by the Observable,\n    or elements returned by the elementSelector function.\n    "},examples:[{name:"Group objects by id and return as array",code:"\n        interface Obj {\n          id: number;\n          name: string;\n        }\n        Rx.Observable.of<Obj>({id: 1, name: 'aze1'},\n                              {id: 2, name: 'sf2'},\n                              {id: 2, name: 'dg2'},\n                              {id: 1, name: 'erg1'},\n                              {id: 1, name: 'df1'},\n                              {id: 2, name: 'sfqfb2'},\n                              {id: 3, name: 'qfs3'},\n                              {id: 2, name: 'qsgqsfg2'})\n          .groupBy(p => p.id)\n          .flatMap( (group$) => group$.reduce((acc, cur) => [...acc, cur], []))\n          .subscribe(p => console.log(p));\n        /*\n          Output:\n          [ { id: 1, name: 'aze1' },\n            { id: 1, name: 'erg1' },\n            { id: 1, name: 'df1' } ]\n\n          [ { id: 2, name: 'sf2' },\n            { id: 2, name: 'dg2' },\n            { id: 2, name: 'sfqfb2' },\n            { id: 2, name: 'qsgqsfg2' } ]\n\n          [ { id: 3, name: 'qfs3' } ]\n        */\n        ",externalLink:{platform:"JSBin",url:"http://jsbin.com/linekelumo/1/embed?js,console"}},{name:"Pivot data on the id field",code:"\n      interface Obj {\n        id: number;\n        name: string;\n      }\n      Rx.Observable.of<Obj>({id: 1, name: 'aze1'},\n                            {id: 2, name: 'sf2'},\n                            {id: 2, name: 'dg2'},\n                            {id: 1, name: 'erg1'},\n                            {id: 1, name: 'df1'},\n                            {id: 2, name: 'sfqfb2'},\n                            {id: 3, name: 'qfs1'},\n                            {id: 2, name: 'qsgqsfg2'})\n        .groupBy(p => p.id, p => p.name)\n        .flatMap( (group$) => group$.reduce((acc, cur) => [...acc, cur], [\"\" + group$.key]))\n        .map(arr => ({'id': parseInt(arr[0]), 'values': arr.slice(1)}))\n        .subscribe(p => console.log(p));\n      /*\n        Output:\n        { id: 1, values: [ 'aze1', 'erg1', 'df1' ] }\n\n        { id: 2, values: [ 'sf2', 'dg2', 'sfqfb2', 'qsgqsfg2' ] }\n\n        { id: 3, values: [ 'qfs1' ] }\n      */\n        ",externalLink:{platform:"JSBin",url:"http://jsbin.com/racikizeji/embed?js,console"}}],relatedOperators:[],additionalResources:[]},{name:"map",operatorType:"transformation",signature:"public map(project: Function, thisArg: any): Observable",parameters:[{name:"project",type:"(value: T, index: number) => R",attribute:"",description:"The function to apply to each 'value' emitted by the source Observable. The 'index' parameter is the number 'i'\n        for the i-th emission that has happened since the subscription, starting from the number '0'."},{name:"thisArg",type:"any",attribute:"optional",description:"An optional argument to define what this is in the 'project' function."}],marbleUrl:"http://reactivex.io/rxjs/img/map.png",shortDescription:{description:'\n      Applies a given <span class="markdown-code">project</span> function to each value emitted by the source\n      Observable, and emits the resulting values as an Observable.\n    ',extras:[]},walkthrough:{description:'\n      <p>\n        Similar to the well known\n        <a\n          href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map"\n          target="_blank"\n          class="markdown-code">\n          Array.prototype.map\n        </a> function,\n        this operator applies a projection to each value and emits that projection in the output\n        Observable.\n      </p>\n    '},examples:[{name:"Map every click to the clientX position of that click",code:"\n        const clicks = Rx.Observable.fromEvent(document, 'click');\n        const positions = clicks.map(ev => ev.clientX);\n        positions.subscribe(x => console.log(x));\n      ",externalLink:{platform:"JSBin",url:"http://jsbin.com/detidogile/embed?js,console,output"}}],relatedOperators:["mapTo","pluck"],additionalResources:[]},{name:"mapTo",operatorType:"transformation"},{name:"mergeMap",operatorType:"transformation"},{name:"partition",operatorType:"transformation",signature:"public partition(predicate: function(value: T, index: number): boolean, thisArg: any): [Observable<T>, Observable<T>]",marbleUrl:"http://reactivex.io/rxjs/img/partition.png",parameters:[{name:"predicate",type:"function(value: T, index: number): boolean",attribute:"",description:"A function that evaluates each value emitted by the source Observable. If it returns 'true', the value is emitted on the\n      first Observable in the returned array, if 'false' the value is emitted on the second Observable in the array. The 'index' parameter\n      is the number 'i' for the i-th source emission that has happened since the subscription, starting from the number '0'."},{name:"thisArg",type:"any",attribute:"optional",description:"An optional argument to determine the value of 'this' in the predicate function."}],shortDescription:{description:"Splits the source Observable into two, one with values that satisfy a predicate, and another with values\n      that don't satisfy the predicate.",extras:[{type:"Tip",text:'\n        It\'s like <a href="#/operators/filter" class="markdown-code">filter</a>, but returns two Observables: one like the output of\n        <a href="#/operators/filter" class="markdown-code">filter</a>, and the other with values that did not pass the condition.\n        '}]},walkthrough:{description:'\n      <p>\n        <span class="markdown-code">partition</span> outputs an array with two Observables that partition the values from the source\n        Observable through the given <span class="markdown-code">predicate</span> function. The first Observable in that array emits\n        source values for which the predicate argument returns true. The second Observable emits source values for which the predicate\n        returns false. The first behaves like <a href="#/operators/filter" class="markdown-code">filter</a> and the second behaves like\n        <a href="#/operators/filter" class="markdown-code">filter</a> with the predicate negated.\n      </p>\n    '},examples:[{name:"Partition click events into those on DIV elements and those elsewhere",code:"\n        const clicks = Rx.Observable.fromEvent(document, 'click');\n        const parts = clicks.partition(ev => ev.target.tagName === 'DIV');\n        const clicksOnDivs = parts[0];\n        const clicksElsewhere = parts[1];\n        clicksOnDivs.subscribe(x => console.log('DIV clicked: ', x));\n        clicksElsewhere.subscribe(x => console.log('Other clicked: ', x));\n      ",externalLink:{platform:"JSBin",url:"http://jsbin.com/vekisov/embed?js,console,output"}}],relatedOperators:["filter"],additionalResources:[]},{name:"pluck",operatorType:"transformation",signature:"public pluck(properties: ...string): Observable",marbleUrl:"http://reactivex.io/rxjs/img/pluck.png",parameters:[{name:"properties",type:"...string",attribute:"",description:"\n        The nested properties to 'pluck' from each source value (an object).\n      "}],shortDescription:{description:"Maps each source value (an object) to its specified nested property.",extras:[{type:"Tip",text:'\n          Like <a href="#/operators/map" class="markdown-code">map</a>, but meant\n          only for picking one of the nested properties of every emitted object.\n        '}]},walkthrough:{description:'\n      <p>\n        Given a list of strings describing a path to an object property, retrieves\n        the value of a specified nested property from all values in the source Observable.\n        If a property can\'t be resolved, it will return <span class="markdown-code">undefined</span>\n        for that value.\n      </p>\n    '},examples:[{name:"Map every every click to the tagName of the clicked target element",code:"\n        const clicks = Rx.Observable.fromEvent(document, 'click');\n        const tagNames = clicks.pluck('target', 'tagName');\n        tagNames.subscribe(x => console.log(x));\n      ",externalLink:{platform:"JSBin",url:"http://jsbin.com/vucuca/embed?js,console,output"}}],relatedOperators:["map"],additionalResources:[]},{name:"scan",operatorType:"transformation",signature:"public scan(accumulator: Function, seed: any): Observable",parameters:[{name:"accumulator",type:"(acc: R, value: T, index: number) => R",attribute:"",description:"The accumulator function called on each source value."},{name:"seed",type:"T|R",attribute:"optional",description:"The initial accumulation value."}],useInteractiveMarbles:!0,marbleUrl:"http://reactivex.io/rxjs/img/scan.png",shortDescription:{description:'\n          Applies an <span class="markdown-code">accumulator</span> function over the source Observable, and\n          returns each intermediate result, with an optional <span class="markdown-code">seed</span> value.\n      ',extras:[]},walkthrough:{description:'\n          <p>\n              Combines together all values emitted on the source, using an accumulator\n              function that knows how to join a new source value into the accumulation from\n              the past. Is similar to <a href="/operators/reduce" class="markdown-code">reduce</a>, but emits the\n              intermediate accumulations.\n          </p>\n          <p>\n              Returns an Observable that applies a specified <span class="markdown-code">accumulator</span> function to each\n              item emitted by the source Observable. If a <span class="markdown-code">seed</span> value is specified, then\n              that value will be used as the initial value for the accumulator. If no seed value is specified,\n              the first item of the source is used as the seed.\n          </p>\n      '},examples:[{name:"Count the number of click events",code:"\n              let clicks = Rx.Observable.fromEvent(document, 'click');\n              let ones = clicks.mapTo(1);\n              let seed = 0;\n              let count = ones.scan((acc, one) => acc + one, seed);\n              count.subscribe(x => console.log(x));\n          ",externalLink:{platform:"JSBin",url:"http://jsbin.com/qemuzufofo/embed?js,console,output"}}],relatedOperators:["expand","mergeScan","reduce"],additionalResources:[]},{name:"switchMap",operatorType:"transformation",signature:"switchMap(project: (value: T, index: number) => ObservableInput<I>,\n  resultSelector: (outerValue: T, innerValue: I, outerIndex: number, innerIndex: number) => R): Observable",parameters:[{name:"project",type:"function(value: T, index: number): ObservableInput",attribute:"",description:"A function that, when applied to an item emitted by the source\n       Observable, returns an Observable."},{name:"resultSelector",type:"function(outerValue: T, innerValue: I, outerIndex: number, innerIndex: number): any",attribute:"optional",description:"A function to produce the value on the output Observable based on the values\n      and the indices of the source (outer) emission and the inner Observable\n      emission. The arguments passed to this function are:\n      - 'outerValue': the value that came from the source.\n      - 'innerValue': the value that came from the projected Observable.\n      - 'outerIndex': the \"index\" of the value that came from the source.\n      - 'innerIndex': the \"index\" of the value from the projected Observable."}],marbleUrl:"http://reactivex.io/rxjs/img/switchMap.png",shortDescription:{description:'Projects each source value to an Observable which is merged in the output\n    Observable, emitting values only from the most recently projected Observable.\n\n    <span class="informal">Maps each value to an Observable, then flattens all of\n    these inner Observables using <code>switch</code>.</span>'},walkthrough:{description:'Returns an Observable that emits items based on applying a function that you\n    supply to each item emitted by the source Observable, where that function\n    returns an (so-called "inner") Observable. Each time it observes one of these\n    inner Observables, the output Observable begins emitting the items emitted by\n    that inner Observable. When a new inner Observable is emitted, <code>switchMap</code>\n    stops emitting items from the earlier-emitted inner Observable and begins\n    emitting items from the new one. It continues to behave like this for\n    subsequent inner Observables.'},examples:[{name:"Rerun an interval Observable on every click even",code:"\n      const clicks = Rx.Observable.fromEvent(document, 'click');\n      const result = clicks.switchMap((ev) => Rx.Observable.interval(1000));\n      result.subscribe(x => console.log(x));\n      ",externalLink:{platform:"JSBin",url:"http://jsbin.com/yehawof/edit?js,console,output"}}],relatedOperators:["concatMap","exhaustMap","mergeMap","switch","switchMapTo"]},{name:"window",operatorType:"transformation",signature:"public window(windowBoundaries: Observable<any>): Observable<Observable<T>>",parameters:[{name:"windowBoundaries",type:"Observable<any>",attribute:"",description:"An Observable that completes the previous window and starts a new window."}],marbleUrl:"http://reactivex.io/rxjs/img/window.png",shortDescription:{description:'\n      Branch out the source Observable values as a nested Observable\n      whenever <span class="markdown-code">windowBoundaries</span> emits.\n    ',extras:[{type:"Tip",text:'\n          It\'s like  <a href="#/operators/buffer" class="markdown-code">buffer</a>,\n          but emits a nested Observable instead of an array.\n        '}]},walkthrough:{description:'\n      <p>\n        Returns an Observable that emits windows of items it collects\n        from the source Observable. The output Observable emits connected,\n        non-overlapping windows. It emits the current window and opens a new\n        one whenever the Observable <span class="markdown-code">windowBoundaries</span>\n        emits an item. Because each window is an Observable, the output is a higher-order Observable.\n      </p>\n    '},examples:[{name:"In every window of 1 second each, emit at most 2 click events",code:"\n        const clicks = Rx.Observable.fromEvent(document, 'click');\n        const interval = Rx.Observable.interval(1000);\n        const result = clicks.window(interval)\n          .map(win => win.take(2)) // each window has at most 2 emissions\n          .mergeAll(); // flatten the Observable-of-Observables\n        result.subscribe(x => console.log(x));\n      ",externalLink:{platform:"JSBin",url:"http://jsbin.com/racefub/embed?js,console,output"}}],relatedOperators:["windowCount","windowTime","windowToggle","windowWhen","buffer"]},{name:"windowCount",operatorType:"transformation"},{name:"windowToggle",operatorType:"transformation"},{name:"windowWhen",operatorType:"transformation"}],[{name:"delay",operatorType:"utility",signature:"public delay(delay: number | Date, scheduler: Scheduler): Observable",parameters:[{name:"delay",type:"number | Date",attribute:"",description:"The delay duration in milliseconds (a number) or a Date until which the\n      emission of the source items is delayed."},{name:"scheduer",type:"Scheduler",attribute:"",description:"The IScheduler to use for managing the timers that handle the time-shift for each item."}],useInteractiveMarbles:!0,marbleUrl:"http://reactivex.io/rxjs/img/delay.png",shortDescription:{description:"\n      Delays the emission of items from the source Observable by a given timeout or until a given Date.\n    ",extras:[]},walkthrough:{description:"\n      <p>\n        If the delay argument is a Number, this operator time shifts the source Observable by that amount\n        of time expressed in milliseconds. The relative time intervale between the values are preserved.\n      </p>\n      <p>\n        If the delay argument is a Date, this operator time shifts the start of the Observable execution\n        until the given date occurs.\n      </p>\n    "},examples:[{name:"Delay each click by one second",code:"\n        const clicks = Rx.Observable.fromEvent(document, 'click').mapTo('click');;\n        const delayedClicks = clicks.delay(1000);\n        delayedClicks.subscribe(x => console.log(x));\n      ",externalLink:{platform:"JSBin",url:"http://jsbin.com/howeziyoma/embed?js,console,output"}},{name:"Delay all clicks until a future date happens",code:"\n        const clicks = Rx.Observable.fromEvent(document, 'click');\n        const date = new Date('March 15, 2050 12:00:00');\n        const delayedClicks = clicks.delay(date);\n        delayedClicks.subscribe(x => console.log(x));\n      ",externalLink:{platform:"JSBin",url:"http://jsbin.com/cozogifayu/embed?js,console,output"}}],relatedOperators:["debounceTime","delayWhen"],additionalResources:[]},{name:"delayWhen",operatorType:"utility"},{name:"dematerialize",operatorType:"utility"},{name:"do",operatorType:"utility",signature:"public do(nextOrObserver: Observer | function, error: function, complete: function): Observable",parameters:[{name:"nextOrObserver",type:"Observer|function",attribute:"optional",description:"A normal Observer object or a callback for `next`."},{name:"error",type:"function",attribute:"optional",description:"Callback for errors in the source."},{name:"complete",type:"function",attribute:"optional",description:"Callback for the completion of the source."}],marbleUrl:"http://reactivex.io/rxjs/img/do.png",shortDescription:{description:'Perform a side effect for every emission on the source Observable, but return\n      an Observable that is identical to the source.\n      <span class="informal">Intercepts each emission on the source and runs a\n      function, but returns an output which is identical to the source as long as errors don\'t\n      occur.</span>'},walkthrough:{description:'\n      <p>Returns a mirrored Observable of the source Observable,\n      but modified so that the provided Observer is called to perform a side effect for every\n      value, error, and completion emitted by the source. Any errors that are thrown in\n      the aforementioned Observer or handlers are safely sent down the error path\n      of the output Observable.\n      </p>\n      <p>\n      This operator is useful for debugging your Observables for the correct values\n      or performing other side effects.\n      </p>\n      <p>\n      Note: this is different to a <span class="markdown-code">subscribe</span> on the Observable. If the Observable\n      returned by <span class="markdown-code">do</span> is not subscribed, the side effects specified by the\n      Observer will never happen. <span class="markdown-code">do</span> therefore simply spies on existing\n      execution, it does not trigger an execution to happen like <span class="markdown-code">subscribe</span> does.</p>\n    '},examples:[{name:"Map every click to the clientX position of that click, while also logging the click event",code:"\n      const clicks = Rx.Observable.fromEvent(document, 'click');\n      const positions = clicks\n         .do(ev => console.log(ev.type))\n         .map(ev => ev.clientX);\n      positions.subscribe(x => console.log(x));\n      ",externalLink:{platform:"JSBin",url:"http://jsbin.com/pijosapixu/embed?js,console,output"}}],relatedOperators:["map","subscribe"]},{name:"let",operatorType:"utility"},{name:"toPromise",operatorType:"utility"}]),I=R,M=R,A=function(){},L=n("911F"),C=n("k1En"),E=n("aayJ"),P=n("dYU3"),U=n("UHIZ"),B=n("Un6q"),D=n("ESfO"),J=n("ghl+"),N=n("V8+5"),q=n("8Xfy"),F=n("yxpl"),W=n("vgc3"),z=n("trMa"),K=n("e0rv"),$=n("l6RC"),G=n("TO51"),V=n("GROE"),Z=this&&this.__assign||Object.assign||function(e){for(var t,n=1,r=arguments.length;n<r;n++){t=arguments[n];for(var a in t)Object.prototype.hasOwnProperty.call(t,a)&&(e[a]=t[a])}return e},X=new S.o("operators"),H=function(){function e(e,t,n){this._breakpointObserver=e,this._operatorMenuService=t,this.operators=n,this._onDestroy=new G.a}return e.prototype.ngOnInit=function(){this.groupedOperators=function(e){return e.reduce(function(e,t){return Z({},e,e[t.operatorType]?(n={},n[t.operatorType]=e[t.operatorType].concat([t]),n):(r={},r[t.operatorType]=[t],r));var n,r},{})}(this.operators),this.categories=Object.keys(this.groupedOperators)},e.prototype.ngAfterContentInit=function(){var e=this;this._operatorMenuService.menuStatus().pipe(Object(V.a)(function(e){return!!e}),Object(V.e)(this._onDestroy)).subscribe(function(t){return e._sidenav.open()})},Object.defineProperty(e.prototype,"extraSmallScreen",{get:function(){return this._breakpointObserver.isMatched("(max-width: 601px)")},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"smallScreen",{get:function(){return this._breakpointObserver.isMatched("(max-width: 901px)")},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"operatorMenuGap",{get:function(){return this.extraSmallScreen?54:64},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"sidenavMode",{get:function(){return this.smallScreen?"over":"side"},enumerable:!0,configurable:!0}),e.prototype.ngOnDestroy=function(){this._onDestroy.next()},e}(),Y=n("3Czw"),Q=n("Wug/"),ee=S._2({encapsulation:0,styles:[["[_nghost-%COMP%]{-webkit-box-flex:1;-ms-flex:1 1 auto;flex:1 1 auto;overflow-y:auto;display:-webkit-box;display:-ms-flexbox;display:flex}.operator-container[_ngcontent-%COMP%]{width:100%}.category-subheader[_ngcontent-%COMP%]{text-transform:uppercase;font-weight:600;color:#fff!important;background:#333}.operator-list-sidenav[_ngcontent-%COMP%]{width:300px}.sidenav-toggle[_ngcontent-%COMP%]{position:fixed;right:20px;bottom:10px;z-index:4}"]],data:{animation:[{type:7,name:"growInOut",definitions:[{type:0,name:"in",styles:{type:6,styles:{opacity:1},offset:null},options:void 0},{type:1,expr:"void => *",animation:[{type:6,styles:{opacity:0,transform:"scale3d(.3, .3, .3)"},offset:null},{type:4,styles:null,timings:"150ms ease-in"}],options:null},{type:1,expr:"* => void",animation:[{type:4,styles:{type:6,styles:{opacity:0,transform:"scale3d(.3, .3, .3)"},offset:null},timings:"150ms ease-out"}],options:null}],options:{}}]}}),te=S._0("app-operators",H,function(e){return S._27(0,[(e()(),S._4(0,0,null,null,1,"app-operators",[],null,null,null,l,ee)),S._3(1,1294336,null,0,H,[Y.a,Q.a,X],null,null)],function(e,t){e(t,1,0)},null)},{},{},[]),ne=function(){function e(){this.operatorExtras=[]}return Object.defineProperty(e.prototype,"tips",{get:function(){return this.operatorExtras.filter(function(e){return"Tip"===e.type})},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"warnings",{get:function(){return this.operatorExtras.filter(function(e){return"Warning"===e.type})},enumerable:!0,configurable:!0}),e}(),re=S._2({encapsulation:0,styles:[[".extra-tip[_ngcontent-%COMP%]{display:-webkit-box;display:-ms-flexbox;display:flex}h3[_ngcontent-%COMP%]{display:inline-block;vertical-align:middle;padding-left:10px}.tip-warning[_ngcontent-%COMP%]{color:#f44336}.tip-info[_ngcontent-%COMP%]{color:#2196f3}"]],data:{}}),ae=function(){},oe=S._2({encapsulation:0,styles:[[".parameter-table[_ngcontent-%COMP%]{border-collapse:collapse;border-radius:2px;border-spacing:0;margin:0 0 32px 0;width:100%}.parameter-table[_ngcontent-%COMP%]   th[_ngcontent-%COMP%]{background-color:#fafafa;max-width:100px;padding:12px 18px;text-align:left;color:rgba(0,0,0,.692);font-weight:400}.parameter-table[_ngcontent-%COMP%]   td[_ngcontent-%COMP%]{font-weight:400;padding:8px 16px;border:1px solid rgba(0,0,0,.03);background-color:#fff}"]],data:{}}),le=n("SMsG"),se=n("YXpL"),ie=function(){},ue=S._2({encapsulation:0,styles:[[".operator-name[_ngcontent-%COMP%]{font-size:30px}.signature[_ngcontent-%COMP%]{margin-bottom:24px}mat-toolbar[_ngcontent-%COMP%]{background:#62757f!important;color:#fff;font-weight:400}"]],data:{}}),ce=function(){},pe=S._2({encapsulation:0,styles:[[".marble-wrapper[_ngcontent-%COMP%]{background-color:#fff;text-align:center}.marble-diagram[_ngcontent-%COMP%]{max-width:640px}@media screen and (max-width:960px){.marble-diagram[_ngcontent-%COMP%]{max-width:100%}}"]],data:{}}),be=function(){function e(e,t){this.elementRef=e,this.zone=t}return e.prototype.ngAfterViewChecked=function(){if(!this._done&&this.elementRef.nativeElement.innerHTML&&this.elementRef.nativeElement.querySelector){var e=this.elementRef.nativeElement.querySelectorAll("pre");this.zone.runOutsideAngular(function(){for(var t=0,n=e;t<n.length;t++){var r=n[t];hljs.highlightBlock(r)}}),this._done=!0}},e}(),me=n("jk5D"),de=n("OFGE"),he=n("4jwp"),fe=function(){function e(e){this._sanitizer=e}return e.prototype.transform=function(e){return e?this._sanitizer.bypassSecurityTrustResourceUrl(e):e},e}(),ve=n("RyBE"),ge=function(){return function(){this.copyToClipboard=new S.m}}(),ye=S._2({encapsulation:0,styles:[[".code-block[_ngcontent-%COMP%]{position:relative}.code-block[_ngcontent-%COMP%]   pre[_ngcontent-%COMP%]{margin-top:0;padding-top:0}.example-options[_ngcontent-%COMP%], .menu-button[_ngcontent-%COMP%]{position:absolute;right:0;top:0}.example-header[_ngcontent-%COMP%]{-ms-flex-line-pack:center;align-content:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-pack:center;-ms-flex-pack:center;justify-content:center;padding:8px 6px 8px 18px;color:rgba(0,0,0,.692);background:#fafafa}.example-header[_ngcontent-%COMP%]   .header-title[_ngcontent-%COMP%]{-webkit-box-flex:1;-ms-flex:1 1 auto;flex:1 1 auto}.code-example[_ngcontent-%COMP%]{margin-bottom:16px}.bin-wrapper[_ngcontent-%COMP%]   iframe[_ngcontent-%COMP%]{border:none;width:100%;height:350px}"]],data:{}}),Oe=function(){},xe=S._2({encapsulation:0,styles:[[""]],data:{}}),ke=function(){},we=S._2({encapsulation:0,styles:[[""]],data:{}}),_e=function(){},Te=S._2({encapsulation:0,styles:[[""]],data:{}}),je=new S.o("operators"),Se=function(){function e(e,t,n,r,a,o){this._router=e,this._activatedRoute=t,this._seo=n,this._copierService=r,this._snackBar=a,this.operators=o,this.operatorsMap=new Map,this.baseSourceUrl="https://github.com/ReactiveX/rxjs/blob/master/src/operators/",this.baseSpecUrl="http://reactivex.io/rxjs/test-file/spec-js/operators"}return e.prototype.ngOnInit=function(){var e=this;this.operators.forEach(function(t){e.operatorsMap.set(t.name,t)}),this._activatedRoute.params.pipe(Object(V.d)("operator")).subscribe(function(t){e.operatorsMap.has(t)?(e.operator=e.operatorsMap.get(t),e.scrollToTop(),e._seo.setHeaders({title:[e.operator.name,e.operator.operatorType],description:e.operator.shortDescription?e.operator.shortDescription.description:""})):e.notfound()})},e.prototype.scrollToTop=function(){var e=document.querySelector(".mat-drawer-content");e&&(e.scrollTop=0)},e.prototype.copyToClipboard=function(e){this._copierService.copyText(e),this._snackBar.open("The example has been copied to your clipboard!",null,{duration:3e3})},Object.defineProperty(e.prototype,"operatorName",{get:function(){return this.operator.name},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"signature",{get:function(){return this.operator.signature||"Signature Placeholder"},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"marbleUrl",{get:function(){return this.operator.marbleUrl},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"useInteractiveMarbles",{get:function(){return this.operator.useInteractiveMarbles},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"shortDescription",{get:function(){return this.operator.shortDescription&&this.operator.shortDescription.description},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"shortDescriptionExtras",{get:function(){return this.operator.shortDescription&&this.operator.shortDescription.extras},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"walkthrough",{get:function(){return this.operator.walkthrough&&this.operator.walkthrough.description},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"walkthroughExtras",{get:function(){return this.operator.walkthrough&&this.operator.walkthrough.extras},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"parameters",{get:function(){return this.operator.parameters||[]},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"examples",{get:function(){return this.operator.examples||[]},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"relatedOperators",{get:function(){return this.operator.relatedOperators||[]},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"sourceUrl",{get:function(){return this.baseSourceUrl+"/"+this.operatorName+".ts"},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"specsUrl",{get:function(){return this.baseSpecUrl+"/"+this.operatorName+"-spec.js.html"},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"additionalResources",{get:function(){return this.operator.additionalResources||[]},enumerable:!0,configurable:!0}),e.prototype.notfound=function(){return this._router.navigate(["/operators"]),{}},e}(),Re=n("g9BA"),Ie=n("Jaoy"),Me=n("LT5m"),Ae=S._2({encapsulation:0,styles:[[".main-operator-container[_ngcontent-%COMP%]{padding:5px;display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-orient:vertical;-webkit-box-direction:normal;-ms-flex-direction:column;flex-direction:column;padding:0 16px;margin-bottom:32px}.short-description[_ngcontent-%COMP%]{margin:16px 0 32px}.margin-bottom-32[_ngcontent-%COMP%]{margin-bottom:32px}.margin-bottom-16[_ngcontent-%COMP%]{margin-bottom:16px}"]],data:{}}),Le=S._0("app-operator",Se,function(e){return S._27(0,[(e()(),S._4(0,0,null,null,1,"app-operator",[],null,null,null,j,Ae)),S._3(1,114688,null,0,Se,[U.l,U.a,Re.a,Ie.a,Me.b,je],null,null)],function(e,t){e(t,1,0)},null)},{},{},[]),Ce=n("9iV4"),Ee=n("ka8K"),Pe=n("j5BN"),Ue=n("R1vt"),Be=n("zQfh"),De=n("CZgk"),Je=n("FhOc"),Ne=n("RXNa"),qe=n("Ioj9"),Fe=n("Lpd/"),We=n("SlD5"),ze=n("hxQ8"),Ke={title:["Operators"],description:"All the RxJS operators..."},$e=function(){};n.d(t,"OperatorsModuleNgFactory",function(){return Ge});var Ge=S._1(A,[],function(e){return S._15([S._16(512,S.j,S.X,[[8,[L.a,C.a,C.b,te,Le]],[3,S.j],S.v]),S._16(4608,B.m,B.l,[S.s,[2,B.s]]),S._16(6144,$.b,null,[B.d]),S._16(4608,$.c,$.c,[[2,$.b]]),S._16(4608,N.a,N.a,[]),S._16(5120,W.d,W.a,[[3,W.d],[2,Ce.a],ve.c]),S._16(4608,q.h,q.h,[N.a]),S._16(4608,q.g,q.g,[q.h,S.x,B.d]),S._16(136192,q.c,q.b,[[3,q.c],B.d]),S._16(5120,q.k,q.j,[[3,q.k],[2,q.i],B.d]),S._16(5120,q.f,q.d,[[3,q.f],S.x,N.a]),S._16(5120,he.d,he.b,[[3,he.d],S.x,N.a]),S._16(5120,he.g,he.f,[[3,he.g],N.a,S.x]),S._16(4608,de.f,de.f,[he.d,he.g,S.x]),S._16(5120,de.c,de.g,[[3,de.c],B.d]),S._16(4608,de.k,de.k,[he.g,B.d]),S._16(5120,de.d,de.j,[[3,de.d],B.d]),S._16(4608,de.a,de.a,[de.f,de.c,S.j,de.k,de.d,S.g,S.p,S.x,B.d]),S._16(5120,de.h,de.i,[de.a]),S._16(5120,Ee.b,Ee.c,[[3,Ee.b]]),S._16(4608,Pe.d,Pe.d,[]),S._16(5120,Ue.b,Ue.d,[de.a]),S._16(5120,me.a,me.b,[de.a]),S._16(5120,Be.a,Be.c,[]),S._16(4608,Be.b,Be.b,[Be.a]),S._16(4608,Be.k,Be.k,[S.x,B.d]),S._16(5120,Be.l,Be.j,[[3,Be.l],Be.b,Be.k]),S._16(5120,Be.o,Be.n,[[3,Be.o],Be.k,Be.b]),S._16(4608,Y.d,Y.d,[N.a]),S._16(135680,Y.a,Y.a,[Y.d,S.x]),S._16(4608,Me.b,Me.b,[de.a,q.k,S.p,Y.a,[3,Me.b]]),S._16(512,B.c,B.c,[]),S._16(512,$.a,$.a,[]),S._16(256,Pe.e,!0,[]),S._16(512,Pe.k,Pe.k,[[2,Pe.e]]),S._16(512,N.b,N.b,[]),S._16(512,se.b,se.b,[]),S._16(512,W.c,W.c,[]),S._16(512,Pe.u,Pe.u,[]),S._16(512,q.a,q.a,[]),S._16(512,J.c,J.c,[]),S._16(512,Pe.l,Pe.l,[]),S._16(512,Pe.s,Pe.s,[]),S._16(512,P.c,P.c,[]),S._16(512,De.f,De.f,[]),S._16(512,he.c,he.c,[]),S._16(512,de.e,de.e,[]),S._16(512,K.h,K.h,[]),S._16(512,Je.c,Je.c,[]),S._16(512,Ne.a,Ne.a,[]),S._16(512,qe.g,qe.g,[]),S._16(512,Fe.a,Fe.a,[]),S._16(512,We.a,We.a,[]),S._16(512,Ue.c,Ue.c,[]),S._16(512,me.d,me.d,[]),S._16(512,Be.m,Be.m,[]),S._16(512,Be.e,Be.e,[]),S._16(512,Y.c,Y.c,[]),S._16(512,Me.d,Me.d,[]),S._16(512,ze.a,ze.a,[]),S._16(512,U.o,U.o,[[2,U.t],[2,U.l]]),S._16(512,$e,$e,[]),S._16(512,A,A,[]),S._16(256,K.a,!1,[]),S._16(256,Ue.a,{overlapTrigger:!0,xPosition:"after",yPosition:"below"},[]),S._16(1024,U.j,function(){return[[{path:"",component:H,data:Ke,children:[{path:":operator",component:Se},{path:"",redirectTo:"combineAll",pathMatch:"full"}]}]]},[]),S._16(256,X,I,[]),S._16(256,je,M,[])])})}});